=begin
#===============================================================================
  RPGM VX Ace - Bugfix Suite [Top Segment]
  Author: Compiled by Black Wyvern, Authored by Various Others
  Created: 03/20/16
  Updated: 03/20/16
#===============================================================================
  *** Only for RPG Maker VX Ace. ***
  ------------------------------------------------------------------------------
  To install this script, open up your script editor and copy/paste this script
  to the first open slot below ▼ Materials. Remember to save.
  
  Terms of use:
    1. Give credit where credit is due.
    2. Free to use in any progect.

  Summary of Modules Included
    - Large Sprite ☆ Display Fix v1.3
    - Elemental Merger v1.01
    - Picture Bug Fix
    - Map Scroll Glitch Fix
    - Dual wield / Two-handed Fix
    - Undefeated Hidden Enemies Visual Fix
    - Vehicle BGM Fix
    - Display Rounding Fix
    - Arrow Display Error Fix
    - Invalid Character Fix
    - Tile Passabilities Fix
    - Screen Shake Fix
    - Text Cache
    - Plane Rewrite
    - Map Name on Load Fix

  Description:
    A large collection of bugfixes to the default VXAce Engine I've collected
    and normalized. Each one can be enabled/disabled as you please.

    Key:
      A: Aliased
      O: Overridden
      N: Newly Defined
  
    - Large Sprite ☆ Display Fix v1.3
      Lines:
      Created by: Neon Black
      Edits Classes / Methods:
        Sprite_Character
          A: update_bitmap
          A: update_position
          A: dispose
          N: sprite_is_onscreen?
          N: get_edge_corner_dis
          N: check_encompassed_area
          N: set_upper_sprite
        Game_Event
          A: setup_page_settings
          N: get_large_sprite_conditions

    - Elemental Merger v1.01
      Created by: Craze
      Edits Classes / Methods:
        Game_Battler
          A: item_element_rate

    - Picture Bug Fix
      Created by: Mithran
      Edits Classes / Methods:
        Sprite_Picture
          O: update_bitmap
        Spriteset_Map
          O: update_pictures
        Game_Pictures
          O: remove

    - Map Scroll Glitch Fix
      Created by: wltr3565
      Edits Classes / Methods:
        Game_Map
          O: scroll_down
          O: set_display_pos

    - Dual wield / Two-handed Fix
      Created by: Trihan
      Edits Classes / Methods:
        RPG::Weapon
          N: two_handed?
        Game_BattlerBase
          A: equippable?
        Game_Actor
          O: release_unequippable_items
        Window_EquipSlot
          A: enable?
        Window_EquipItem
          A: include?

    - Undefeated Hidden Enemies Visual Fix
      Created by: DerTraveler
      Edits Classes / Methods:
        Game_Enemy
          O: on_battle_end

    - Vehicle BGM Fix
      Created by: Hime
      Edits Classes / Methods:
        Game_Map
          A: autoplay
          O: play_music
        Game_Player
          O: is_walk?
        Game_Vehicle
          A: get_on
          A: get_off

    - Display Rounding Fix
      Created by: Neon Black.
      Edits Classes / Methods:
        Game_Map
          O: display_x
          O: display_y
          O: adjust_x(x)
          O: adjust_y(y)

    - Arrow Display Error Fix
      Created by: Mezzolan
      Edits Classes / Methods:
        Font
          N: Use
        Window_EquipStatus
          A: draw_right_arrow

    - Invalid Character Fix
      Created by: LoneWolf
      Edits Classes / Methods:
        Window_Base
          A: process_normal_character

    - Tile Passabilities Fix
      Created by: Neon Black
      Edits Classes / Methods:
        Game_Map
          O: check_passage

    - Screen Shake Fix
      Created by: Hiino
      Edits Classes / Methods:
        Game_Interpreter
          O: command_225

    - Text Cache
      Created by: Mithran
      Edits Classes / Methods:
        Bitmap
          A: draw_text
          N: check_squeeze_allowed
          N: draw_text_cached
        N: TextCache
          N: self.canvas
          N: self.letters
          N: self.empty_bitmap
          N: self.new_letter
          N: self.create_font
          N: self.include?
          N: self.clear
        Font
          N: to_a

    - Plane Rewrite
      Created by: FenixFyreX Patched by: Azuma-01
      Edits Classes / Methods:
        Bitmap
          A: Initialize
        Cache
          N: self.plane_cache
        Plane
          O: initialize
          O: dispose
          O: bitmap_disposed?
          O: disposed?
          O: ox=
          O: oy=
          O: bitmap
          O: viewport=
          O: bitmap=
          O: method_missing
          N: error_disposed
          O: vrect
        Rect
          N: to_a
        Spriteset_Map
          O: update_parallax

    - Map Name on Load Fix
      Created by: Crazyninjaguy
      Edits Classes / Methods:
        Window_MapName
          A: initialize
          O: draw_background
          O: refresh

  Configuration:
    - Script Master
      Fixes can be enabled/disabled as one desires.

    - Large Sprite ☆ Display Fix v1.3
      LSDF_UPPER_TERRAIN the terrain marker used to calculate correct display.
      LSDF_TURNING corrects render of characters with ! in their name.

    - Elemental Merger v1.01
      Settings for processing of element rates with different attack types
      Settings for how to apply elemental rates

    - Arrow Display Error Fix
      Set override font to use to display arrows correctly.

    - Text Cache
      Configuration for cacheing options, and display safeguards.
        
  Instructions:
    - Large Sprite ☆ Display Fix v1.3
      Add <large sprite> to Event Notebox if Event is Oversized

    - Dual wield / Two-handed Fix
      Make two-handed weapons "seal shield".

  Optional:
    - None
  
  Dependencies:
    - None
  
  Compatibility:
    - None

  Credits:
    - Neon Black
    - Craze
    - Mithran
    - wltr3565
    - Trihan
    - Hime
    - Mezzolan
    - LoneWolf
    - Hiino
    - Azuma-01
#===============================================================================
=end

if true # Turns the script on or off.
  ($imported||={})["BWA_BugFixesTop"]=[true,1.0]
  # ^ Signifies that the script is installed to other scripts.

#===============================================================================
# Bugfix Collected Vars
#===============================================================================
module BWX_BF
  #=============================================================================
  # ► BEGIN [Script Master Enable]
  #=============================================================================
  BGFX_LSSDF = true   # - Large Sprite ☆ Display Fix v1.3
  BGFX_ELEMG = true   # - Elemental Merger v1.01
  BGFX_PICBF = true   # - Picture Bug Fix
  BGFX_MSGBF = true   # - Map Scroll Glitch Fix
  BGFX_DWTHF = true   # - Dual wield / Two-handed Fix
  BGFX_UHEVF = true   # - Undefeated Hidden Enemies Visual Fix
  BGFX_VBGMF = true   # - Vehicle BGM Fix
  BGFX_DSPRF = true   # - Display Rounding Fix
  BGFX_ADEBF = true   # - Arrow Display Error Fix
  BGFX_INVLD = true   # - Invalid Character Fix
  BGFX_TILEP = true   # - Tile Passabilities Fix
  BGFX_SCRNS = true   # - Screen Shake Fix
  BGFX_TEXTC = true   # - Text Cache
  BGFX_PLANE = true   # - Plane Rewrite
  BGFX_MNOLF = true   # - Map Name on Load Fix
  #=============================================================================
  # ► BEGIN [Script Master Enable]
  #=============================================================================
  
  #=============================================================================
  # ► BEGIN [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  LSDF_UPPER_TERRAIN =  7
  LSDF_TURNING       = -1
  #=============================================================================
  # ► END [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  
  #=============================================================================
  # ► BEGIN [Elemental Merger v1.01]
  #=============================================================================
  PHYS_ATK_ELEMENTS   = true  # Calculate proper elemental damage for phys atts
  MAGIC_ATK_ELEMENTS  = true  # Calculate proper elemental damage for mag atts
  CERT_ATK_ELEMENTS   = true  # Calculate proper elemental damage for certainhit
  IGNORE_RECOVERY     = true  # Do not calculate elemental bias for healing
  # 0: Default RMAce. Will find the best rate out of all potential elements
  # 1: Addititive
  # 2: Multiplicative
  # 3: Multiplicative Psuedo-Null
  MERGE_TYPE = 3
  # If MERGE_TYPE 3, nul elements will divide damage done by this amount.
  PSUEDO_NULL_AMT = 10 
  # Deal no damage if adjusted damage is below this ammount.
  AUTO_NULL_PER = 10
  #=============================================================================
  # ► END [Elemental Merger v1.01]
  #=============================================================================
  
  #=============================================================================
  # ► BEGIN [Arrow Display Error Fix]
  #=============================================================================
  ARROW_FONT = Font.new(["VL Gothic", "Arial"])
  #=============================================================================
  # ► END [Arrow Display Error Fix]
  #=============================================================================
  
  #=============================================================================
  # ► BEGIN [Text Cache]
  #=============================================================================
  DISABLE_TEXT_SQUEEZE = false # Set true to completely disable all built in
  # text squeezing methods.
  TEXT_SQUEEZE_MIN_TRIGGER_RATE = 1.5 # How much the text must exceed it's
  # assigned width to squeeze. Set to 1.0 to disable.
  TEXT_TOP_BUFFER = 2   # Buffer in pixels to draw text away from the edge of
  TEXT_SIDE_BUFFER = 8  # the bitmap, to prevent characters from being cut off.
  SIMPLE_FIX = false    # Just adds the two pixels to prevent needless squeeze.
  # [Depricated] as doing so causes the other mentioned bugs to still appear.
  MAX_TEXT_DRAW_WIDTH = 640 # Draws fail at ~640px set nil for no max width.
  MAX_TEXT_DRAW_WIDTH_ABSOLUTE = 2016 # The absolute limit accepted by draw_text
  # This prevents a crash when the draw_text is called to a small space with a
  # ton of text any text longer than this will be automatically drawn without
  # squeezing this option should NEVER trigger either way
  NO_FIX = false # Completely disables the fix, for testing comparison.
  BUFFER_DRAW = 300 # For drawing characters, to make sure there is enough room.
  #=============================================================================
  # ► END [Text Cache]
  #=============================================================================
end

#===============================================================================
#   ►►► WARNING: YOU PROBABLY SHOULDN'T EDIT ANYTHING BELOW THIS POINT ◄◄◄
#   ►►►  CUZ YEAH, THERE'S NOTHING REALLY CONFIGURABLE, AND IT DOESN'T ◄◄◄
#   ►►►              LIKE IT WHEN YOU TOUCH IT THAT WAY.               ◄◄◄
#===============================================================================

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►               Large Sprite ☆ Display Fix v1.3                 ◄◄◄
#===============================================================================
if BWX_BF::BGFX_LSSDF
#===============================================================================
# Sprite Character
#===============================================================================
class Sprite_Character < Sprite_Base
  #=============================================================================
  # Alias: Update Bitmap [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  alias bugfix_sc_ub update_bitmap
  def update_bitmap(*args)
    if graphic_changed? && @set_upper_area_sprite
      @force_no_gfx_change = true
    else
      @force_no_gfx_change = false
    end
    bugfix_sc_ub(*args)
  end

  #=============================================================================
  # Alias: Update Position [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  alias bugfix_sc_up update_position
  def update_position(*args)
    bugfix_sc_up(*args)
    check_encompassed_area if sprite_is_onscreen?
  end

  #=============================================================================
  # Alias: Dispose [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  alias bugfix_sc_dispose dispose
  def dispose(*args)
    @upper_area_sprite.dispose if @upper_area_sprite
    bugfix_sc_dispose(*args)
  end

  #=============================================================================
  # Is Sprite Onscreen? [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  def sprite_is_onscreen?
    return false if @character.is_a?(Game_Vehicle) ||
                    @character.is_a?(Game_Follower)
    return false unless @character.is_a?(Game_Player) || @character.large_sprite
    return false if @character.screen_z >= 200
    top_left, bot_right = get_edge_corner_dis
    return false if top_left[0] > Graphics.width
    return false if top_left[1] > Graphics.height
    return false if bot_right[0] < 0
    return false if bot_right[1] < 0
    return true
  end

  #=============================================================================
  # Get Edge Corner Distance [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  def get_edge_corner_dis
    top_left = [self.x - self.ox, self.y - self.oy]
    bot_right = [top_left[0] + self.width, top_left[1] + self.height]
    return [top_left, bot_right]
  end

  #=============================================================================
  # Check Encompassed Area [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  def check_encompassed_area
    if @set_upper_area_sprite && !@force_no_gfx_change
      old_src = self.src_rect.clone
      self.bitmap = @old_bitmap
      self.src_rect = old_src
    end
    @set_upper_area_sprite = false
    top_left, bot_right = get_edge_corner_dis
    last_x, last_y, copy_region = nil, nil, 0
    map_xd, map_yd = $game_map.display_x * 32, $game_map.display_y * 32
    total_height = (self.height + @character.jump_height).round
    self.width.times do |x|
      xp = map_xd.to_i + top_left[0] + x
      unless xp / 32 == last_x
        last_x = xp / 32
        last_y, copy_region = nil, 0
        total_height.times do |y|
          yp = map_yd.to_i + bot_right[1] + @character.jump_height - y +
            BWX_BF::LSDF_TURNING
          next if yp.to_i / 32 == last_y
          last_y = yp.to_i / 32
          if last_y == (@character.screen_y + @character.jump_height +
              BWX_BF::LSDF_TURNING + map_yd).to_i / 32
            break if $game_map.terrain_tag(
              last_x, last_y) == BWX_BF::LSDF_UPPER_TERRAIN
            next
          end
          next if $game_map.terrain_tag(
            last_x, last_y) != BWX_BF::LSDF_UPPER_TERRAIN
          copy_region = [self.height, total_height - y + 1].min
          set_upper_sprite
          break
        end
      end
      next if copy_region == 0
      rect = Rect.new(src_rect.x + x, src_rect.y, 1, copy_region)
      @upper_area_sprite.bitmap.blt(x, 0, self.bitmap, rect)
      self.bitmap.clear_rect(rect)
    end
    if !@set_upper_area_sprite && @upper_area_sprite
      @upper_area_sprite.visible = false
    end
  end

  #=============================================================================
  # Set Upper Sprite [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  def set_upper_sprite
    return if @set_upper_area_sprite
    @upper_area_sprite ||= Sprite.new
    @upper_area_sprite.bitmap = Bitmap.new(self.width, self.height)
    props = ["x", "y", "ox", "oy", "zoom_x", "zoom_y", "angle", "mirror",
             "bush_depth", "opacity", "blend_type", "color", "tone", "visible",
             "viewport"]
    props.each do |meth|
      @upper_area_sprite.method("#{meth}=").call(self.method(meth).call)
    end
    @upper_area_sprite.z = 200
    @set_upper_area_sprite = true
    @old_bitmap, old_src_rect = self.bitmap, self.src_rect.clone
    self.bitmap = Bitmap.new(@old_bitmap.width, @old_bitmap.height)
    self.bitmap.blt(0, 0, @old_bitmap, @old_bitmap.rect)
    self.src_rect = old_src_rect
  end
end

#===============================================================================
# Game Event
#===============================================================================
class Game_Event < Game_Character
  attr_reader :large_sprite
  #=============================================================================
  # Alias: Setup Page Settings [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  alias bugfix_ge_sps setup_page_settings
  def setup_page_settings(*args)
    bugfix_ge_sps(*args)
    get_large_sprite_conditions
  end

  #=============================================================================
  # Get Large Sprite Conditions [Large Sprite ☆ Display Fix v1.3]
  #=============================================================================
  def get_large_sprite_conditions
    @large_sprite = false
    return if @list.nil? || @list.empty?
    @list.each do |line|
      next unless line.code == 108 || line.code == 408
      case line.parameters[0]
      when /<large sprite>/i
        @large_sprite = true
      end
    end
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                    Elemental Merger v1.01                      ◄◄◄
#===============================================================================
if BWX_BF::BGFX_ELEMG
#===============================================================================
# Game Battler
#===============================================================================
class Game_Battler
  #=============================================================================
  # Item Element Rate [Elemental Merger v1.01]
  #=============================================================================
  def item_element_rate(user, item)
    return 1.0 if item.damage.recover? and BWX_BF::IGNORE_RECOVERY
    array = []
    if !user.atk_elements.empty?
      array+=user.atk_elements if item.physical? and BWX_BF::PHYS_ATK_ELEMENTS
      array+=user.atk_elements if item.magical?  and BWX_BF::MAGIC_ATK_ELEMENTS
      array+=user.atk_elements if item.certain?  and BWX_BF::CERT_ATK_ELEMENTS
    end
    array.push(item.damage.element_id) if item.damage.element_id >= 0
    return 1.0 if array.empty?
    
    rate = 1.0
    case BWX_BF::MERGE_TYPE
      when 1 # Additive
        for i in array
          rate += element_rate(i) - 1.0
        end
      when 2 # Multiplicative
        for i in array
          rate *= element_rate(i)
        end
      when 3 # Multiplicative Psuedo-Null
        for i in array
          rate *= [element_rate(i),(BWX_BF::PSUEDO_NULL_AMT / 100.0)].max
        end
      else # Default (0)
        rate = elements_max_rate(user.array)
    end
    rate = 0 if rate <= (BWX_BF::AUTO_NULL_PER / 100.0) and rate > 0
    rate
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                       Picture Bug Fix                          ◄◄◄
#===============================================================================
if BWX_BF::BGFX_PICBF
#===============================================================================
# Sprite Picture
#===============================================================================
class Sprite_Picture
  #=============================================================================
  # Update Bitmap [Picture Bug Fix]
  #=============================================================================
  def update_bitmap
    self.bitmap = Cache.picture(@picture.name) if @picture.name != @pic_name
    @pic_name = @picture.name
  end
end

#===============================================================================
# Spriteset Map
#===============================================================================
class Spriteset_Map
  #=============================================================================
  # Update Pictures [Picture Bug Fix]
  #=============================================================================
  def update_pictures
    $game_map.screen.pictures.each do |pic|
      @picture_sprites[pic.number] ||= Sprite_Picture.new(@viewport2, pic)
      @picture_sprites[pic.number].update
      if pic.name == ""
        $game_map.screen.pictures.remove(pic.number)
        @picture_sprites[pic.number].dispose
        @picture_sprites[pic.number] = nil
      end
    end
  end
end

#===============================================================================
# Game Pictures
#===============================================================================
class Game_Pictures
  #=============================================================================
  # Remove [Picture Bug Fix]
  #=============================================================================
  def remove(index); @data[index] = nil; end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                    Map Scroll Glitch Fix                       ◄◄◄
#===============================================================================
if BWX_BF::BGFX_MSGBF
#===============================================================================
# Game Map
#===============================================================================
class Game_Map
  #=============================================================================
  # Scroll Down [Map Scroll Glitch Fix]
  #=============================================================================
  def scroll_down(distance) 
    if loop_vertical?
      @display_y += distance
      @display_y %= @map.height
      @parallax_y += distance if @parallax_loop_y
    else
      last_y = @display_y
      @display_y = [@display_y + distance, height - screen_tile_y].min
      @parallax_y += @display_y - last_y
    end
  end 

  #=============================================================================
  # Set Display Pos [Map Scroll Glitch Fix]
  #=============================================================================
  def set_display_pos(x, y) 
    x = [0, [x, width  - screen_tile_x].min].max unless loop_horizontal?
    y = [0, [y, height - screen_tile_y].min].max unless loop_vertical?
    @display_x = (x + width) % width
    @display_y = (y + height) % height
    @display_y = (y + height) % height -
      (Graphics.height % 32 * 1.0 / 32) if @display_y >= @map.height - 12
    @parallax_x = x
    @parallax_y = y
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                 Dual wield / Two-handed Fix                    ◄◄◄
#===============================================================================
if BWX_BF::BGFX_DWTHF
#===============================================================================
# RPG::Weapon
#===============================================================================
class RPG::Weapon < RPG::EquipItem
  #=============================================================================
  # Remove [Dual wield / Two-handed Fix]
  #=============================================================================
  def two_handed?
    for feature in self.features
      return true if feature.code == 54 && feature.data_id == 1
    end
    return false
  end
end

#===============================================================================
# Game_BattlerBase
#===============================================================================
class Game_BattlerBase
  #=============================================================================
  # Alias: Equippable? [Dual wield / Two-handed Fix]
  #=============================================================================
  alias bugfix_gbb_equip? equippable?
  def equippable?(item, slot = nil)
    if slot != nil
      if slot == 1 && dual_wield? && item.is_a?(RPG::Weapon) && 
          equips[0] && equips[0].two_handed?
        return false
      end
    end
    bugfix_gbb_equip?(item)
  end
end

#===============================================================================
# Game_Actor
#===============================================================================
class Game_Actor < Game_Battler
  #=============================================================================
  # Release Unequippable Items [Dual wield / Two-handed Fix]
  #=============================================================================
  def release_unequippable_items(item_gain = true)
    loop do
      last_equips = equips.dup
      @equips.each_with_index do |item, i|
        if !equippable?(item.object, i) || item.object.etype_id != 
            equip_slots[i]
          trade_item_with_party(nil, item.object) if item_gain
          item.object = nil
        end
      end
      return if equips == last_equips
    end
  end
end

#===============================================================================
# Window_EquipSlot
#===============================================================================
class Window_EquipSlot < Window_Selectable
  #=============================================================================
  # Alias: Enable? [Dual wield / Two-handed Fix]
  #=============================================================================
  alias bugfix_wes_enable? enable?
  def enable?(index)
    if @actor.dual_wield? && index == 1 && @actor.equips[0] &&
        @actor.equips[0].two_handed?
      return false
    end
    bugfix_wes_enable?(index)
  end
end
  
#===============================================================================
# Window_EquipItem
#===============================================================================
class Window_EquipItem < Window_ItemList
  #=============================================================================
  # Alias: Include? [Dual wield / Two-handed Fix]
  #=============================================================================
  alias bugfix_wei_include? include?
  def include?(item)
    if @actor.dual_wield? && item.is_a?(RPG::Weapon)
      if @actor.equips[0] != nil && @actor.equips[0].two_handed?&&@slot_id == 1
        return false
      end
      return false if item.two_handed? && @slot_id != 0
    end
    bugfix_wei_include?(item)
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►              Undefeated Hidden Enemies Visual Fix              ◄◄◄
#===============================================================================
if BWX_BF::BGFX_UHEVF
#===============================================================================
# Game Enemy
#===============================================================================
class Game_Enemy < Game_Battler
  #=============================================================================
  # On Battle End [Undefeated Hidden Enemies Visual Fix]
  #=============================================================================
  def on_battle_end
    @result.clear
    remove_battle_states
    remove_all_buffs
    clear_actions
    clear_tp unless preserve_tp?
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                       Vehicle BGM Fix                          ◄◄◄
#===============================================================================
if BWX_BF::BGFX_VBGMF
#===============================================================================
# Game Map
#===============================================================================
class Game_Map
  #=============================================================================
  # Alias: Autoplay [Vehicle BGM Fix]
  #=============================================================================
  alias bugfix_gm_autoplay autoplay
  def autoplay
    return unless $game_player.is_walk?
    bugfix_gm_autoplay 
  end
  
  #=============================================================================
  # Play Music [Vehicle BGM Fix]
  #=============================================================================
  def play_music
    @map.bgm.play if @map.autoplay_bgm
    @map.bgs.play if @map.autoplay_bgs
  end
end

#===============================================================================
# Game Player
#===============================================================================
class Game_Player
  #=============================================================================
  # Is Walk? [Vehicle BGM Fix]
  #=============================================================================
  def is_walk?
    @vehicle_type == :walk
  end
end

#===============================================================================
# Game Vehicle
#===============================================================================
class Game_Vehicle < Game_Character
  #=============================================================================
  # Alias: Get On [Vehicle BGM Fix]
  #=============================================================================
  alias bugfix_gv_get_on get_on
  def get_on
    bugfix_gv_get_on
    @walking_map_id = $game_map.map_id
  end
  
  #=============================================================================
  # Alias: Get Off [Vehicle BGM Fix]
  #=============================================================================
  alias bugfix_gv_get_off get_off
  def get_off
    bugfix_gv_get_off
    if $game_map.map_id != @walking_map_id
      RPG::BGM.stop
      $game_map.play_music
    end
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                     Display Rounding Fix                       ◄◄◄
#===============================================================================
if BWX_BF::BGFX_DSPRF
#===============================================================================
# Game Map
#===============================================================================
class Game_Map
  #=============================================================================
  # Display X [Display Rounding Fix]
  #=============================================================================
  def display_x;  (@display_x * 32).floor.to_f / 32;  end
  
  #=============================================================================
  # Display Y [Display Rounding Fix]
  #=============================================================================
  def display_y;  (@display_y * 32).floor.to_f / 32;  end
  
  #=============================================================================
  # Adjust X [Display Rounding Fix]
  #=============================================================================
  def adjust_x(x)
    if loop_horizontal? && x < display_x - (width - screen_tile_x) / 2
      x - display_x + @map.width
    else
      x - display_x
    end
  end
  
  #=============================================================================
  # Adjust Y [Display Rounding Fix]
  #=============================================================================
  def adjust_y(y)
    if loop_vertical? && y < display_y - (height - screen_tile_y) / 2
      y - display_y + @map.height
    else
      y - display_y
    end
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                   Arrow Display Error Fix                      ◄◄◄
#===============================================================================
if BWX_BF::BGFX_ADEBF
#===============================================================================
# Game Map
#===============================================================================
class Font
  #=============================================================================
  # Use [Arrow Display Error Fix ]
  #=============================================================================
  def use( window )
    old_font = window.contents.font.dup
    window.contents.font = self
    yield
    window.contents.font = old_font  
  end
end

#===============================================================================
# Window Equip Status
#===============================================================================
class Window_EquipStatus
  #=============================================================================
  # Alias: Draw Right Arrow Y [Arrow Display Error Fix ]
  #=============================================================================
  alias bugfix_wes_dra draw_right_arrow
  def draw_right_arrow(x, y)
    BWX_BF::ARROW_FONT.use(self) do
      bugfix_wes_dra(x, y)
    end
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                    Invalid Character Fix                       ◄◄◄
#===============================================================================
if BWX_BF::BGFX_INVLD
#===============================================================================
# Window Base
#===============================================================================
class Window_Base
  #=============================================================================
  # Alias: Process Normal Character [Display Rounding Fix]
  #=============================================================================
  alias bugfix_wb_pnc process_normal_character
  def process_normal_character(c, pos)
    return unless c >= ' '
    bugfix_wb_pnc(c, pos)
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                    Tile Passabilities Fix                      ◄◄◄
#===============================================================================
if BWX_BF::BGFX_TILEP
#===============================================================================
# Game Map
#===============================================================================
class Game_Map
  #=============================================================================
  # Check Passage [Tile Passabilities Fix]
  #=============================================================================
  def check_passage(x, y, bit)
    all_tiles(x, y).each do |tile_id|
      flag = tileset.flags[tile_id]
      if flag & 0x10 != 0                   # [☆]: No effect on passage
        next         if flag & bit == 0     # [○] : Passable but star
        return false if flag & bit == bit   # [×] : Impassable
      else
        return true  if flag & bit == 0     # [○] : Passable
        return false if flag & bit == bit   # [×] : Impassable
      end
    end
    return false                            # Impassable
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                      Screen Shake Fix                          ◄◄◄
#===============================================================================
if BWX_BF::BGFX_SCRNS
#===============================================================================
# Game_Interpreter
#===============================================================================
class Game_Interpreter
  #=============================================================================
  # Command 225 [Screen Shake Fix]
  #=============================================================================
  def command_225
    screen.start_shake(@params[0], @params[1], @params[2])
    wait(@params[2]) if @params[3]
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                          Text Cache                            ◄◄◄
#===============================================================================
if BWX_BF::BGFX_TEXTC
#===============================================================================
# Bitmap
#===============================================================================
class Bitmap
  #=============================================================================
  # Alias: Draw Text [Text Cache]
  #=============================================================================
  alias bugfix_bitmap_dt draw_text
  def draw_text(*args)
    return bugfix_bitmap_dt(*args) if BWX_BF::NO_FIX
    if args[0].is_a?(Rect)
      rect = args[0]
      x, y, width, height = rect.x, rect.y, rect.width, rect.height
      text = args[1].to_s.clone || ""
      align = args[2] || 0
    else
      x, y, width, height = *args[0..3]
      text = args[4].to_s.clone || ""
      align = args[5] || 0
    end
    if check_squeeze_allowed(x, y, width, height, text)
      x -= align
      bugfix_bitmap_dt(x, y, width + 2, height, text, align)
    else
      draw_text_cached(x, y, width, height, text, align)
    end
  end
  
  #=============================================================================
  # Check Squeeze Allowed [Text Cache]
  #=============================================================================
  def check_squeeze_allowed(x, y, width, height, text)
    return false if BWX_BF::DISABLE_TEXT_SQUEEZE
    return false if BWX_BF::MAX_TEXT_DRAW_WIDTH &&
                    width > BWX_BF::MAX_TEXT_DRAW_WIDTH
    text_width = text_size(text).width
    return false if text_width >= BWX_BF::MAX_TEXT_DRAW_WIDTH_ABSOLUTE
    text_width > width * BWX_BF::TEXT_SQUEEZE_MIN_TRIGGER_RATE
  end
  
  #=============================================================================
  # Draw Text Cached [Text Cache]
  #=============================================================================
  def draw_text_cached(x, y, width, height, text, align, allow_squeeze = false)
    text_rect = self.text_size(text)
    text_width = text_rect.width
    text_height = text_rect.height
    if allow_squeeze && text_width > width*BWX_BF::TEXT_SQUEEZE_MIN_TRIGGER_RATE
      ratio = width / text_width.to_f
      ratio = 0.5 if ratio < 0.5
      rect = Rect.new(0, 0, 0, 0)
    else 
      ratio = nil
    end
    fontkey = self.font.to_a
    case align
    when 1; x += (width - text_width) / 2
    when 2; x += width - text_width
    end
    y += (height - text_height) / 2
    buf = -BWX_BF::TEXT_SIDE_BUFFER
    buf *= ratio if ratio
    text.each_char { |char|
    letter = TextCache.letters(fontkey, char)
    if BWX_BF::SIMPLE_FIX
      draw_text_vxa(x + buf, y, letter.rect.width + 2, letter.height, char)
      buf += letter.rect.width - BWX_BF::TEXT_SIDE_BUFFER * 2
    elsif ratio
      w = (ratio * 10).to_i * letter.rect.width / 10 
      rect.set(x + buf, y, w, text_height)
      self.stretch_blt(rect, letter, letter.rect) 
      buf += (letter.rect.width*ratio-BWX_BF::TEXT_SIDE_BUFFER*2*ratio).to_i
    else
      self.blt(x + buf, y, letter, letter.rect)
      buf += letter.rect.width - BWX_BF::TEXT_SIDE_BUFFER * 2
    end
    }
    nil
  end
end

#===============================================================================
# Text Cache
#===============================================================================
module TextCache
  #=============================================================================
  # Canvas [Text Cache]
  #=============================================================================
  def self.canvas(font = nil)
    @canvas = Bitmap.new(32, 32) if @canvas.nil? || @canvas.disposed?
    @canvas
  end

  #=============================================================================
  # Letters [Text Cache]
  #=============================================================================
  def self.letters(font, char)
    @cache ||= {}
    key = font + [char]
    if include?(key)
      return @cache[key]
    elsif char.empty?
      return empty_bitmap
    else
      return new_letter(font, char)
    end
  end

  #=============================================================================
  # Empty Bitmap [Text Cache]
  #=============================================================================
  def self.empty_bitmap
    @cache[:empty] = Bitmap.new(32, 32) unless include?(:empty)
    @cache[:empty]
  end 

  #=============================================================================
  # New Letter [Text Cache]
  #=============================================================================
  def self.new_letter(fontary, char)
    font = create_font(fontary)
    canvas.font = font
    rect = canvas.text_size(char * 3) 
    return @cache[key] = empty_bitmap if (rect.height == 0 || rect.width == 0)
    b = Bitmap.new((rect.width / 3) + BWX_BF::TEXT_SIDE_BUFFER * 2, rect.height)
    b.font = font
    b.bugfix_bitmap_dt(rect.x-b.text_size(" ").width + BWX_BF::TEXT_SIDE_BUFFER,
        rect.y - BWX_BF::TEXT_TOP_BUFFER, BWX_BF::BUFFER_DRAW, rect.height +
        BWX_BF::TEXT_TOP_BUFFER * 2, " #{char} ", 0)
    key = fontary + [char]
    @cache[key] = b    
  end

  #=============================================================================
  # Create Font [Text Cache]
  #=============================================================================
  def self.create_font(fontary)
    font = Font.new(*fontary[0..1])
    font.bold = fontary[2]
    font.italic = fontary[3]
    font.outline = fontary[4]
    font.shadow = fontary[5]
    font.color.set(*fontary[6..9])
    font.out_color.set(*fontary[10..13])
    font
  end

  #=============================================================================
  # Include? [Text Cache]
  #=============================================================================
  def self.include?(key)
    @cache[key] && !@cache[key].disposed?
  end

  #=============================================================================
  # Clear [Text Cache]
  #=============================================================================
  def self.clear
    @cache ||= {}
    @cache.clear
    GC.start
  end
end

#===============================================================================
# Font
#===============================================================================
class Font
  #=============================================================================
  # To Array [Text Cache]
  #=============================================================================
  def to_a
    [name, size, bold, italic, outline, shadow, color.red, color.green,
      color.blue, color.alpha, out_color.red, out_color.green, out_color.blue,
      out_color.alpha]
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                        Plane Rewrite                           ◄◄◄
#===============================================================================
if BWX_BF::BGFX_PLANE

RGSS3Plane = Plane
Object.send(:remove_const, :Plane)
#===============================================================================
# Rect
#===============================================================================
class Rect
  #=============================================================================
  # To_a
  #=============================================================================
  def to_a
    [self.x, self.y, self.width, self.height]
  end
end
#===============================================================================
# Bitmap [Preserving Help Lines in Script, Very Well Documented]
# - Saves a bitmap's name, for future reference.
#===============================================================================
class Bitmap
  #=============================================================================
  # Reinitialize [Plane Rewrite]
  # - Instantiate a bitmap's name, if given one.
  #=============================================================================
	alias bugfix_plane_init initialize
	def initialize(*argv, &argb)
    @name = ''
    if name = argv.find {|arg| arg.is_a?(String) }
      @name = name
    end
    bugfix_plane_init(*argv, &argb)
  end
  attr_reader :name
end

#===============================================================================
# Cache
# - Add in Plane caching, to speed up processing at the slight cost of memory.
#===============================================================================
module Cache
  #=============================================================================
  # Cache::plane_cache [Plane Rewrite]
  # - Convenience method, to not have to type it out in the below methods.
  #=============================================================================
  def self.plane_cache
    @plane_cache ||= {}
  end

  #=============================================================================
  # Cache::plane [Plane Rewrite]
  # - Get a cached plane bitmap.
  # - key : Object  ( most likely an Array e.g. [Rect, String] )
  #=============================================================================
	def self.plane(key)
    return plane_cache[key]
  end

  #=============================================================================
  # Cache::add_plane [Plane Rewrite]
  # - Add a tiled plane bitmap to the cache.
  # - key : Object ( see above )
  # - bmp : Bitmap
  #=============================================================================
  def self.add_plane(key, bmp)
    plane_cache[key] = bmp
  end
  
  #=============================================================================
  # Cache::has_plane? [Plane Rewrite]
  # - Check for a cached plane bitmap.
  # - key : Object ( see above )
  #=============================================================================
  def self.has_plane?(key)
    plane_cache[key].is_a?(Bitmap) && !plane_cache[key].disposed?
  end
  
  class << self; alias bugfix_pc_clear clear; end
  #=============================================================================
  # Cache::clear [Plane Rewrite]
  # - See original documentation.
  #=============================================================================
  def self.clear
    plane_cache.each_value {|v| v.dispose unless v.nil? || v.disposed? }
    plane_cache.clear
    bugfix_pc_clear
  end
  class << self; alias clear_b4_fyx_plane_cache clear; end
end

#===============================================================================
# Plane
# - Tiles a bitmap across either the window rect, or a given viewport's rect.
#===============================================================================
class Plane
  #=============================================================================
  # Initialize [Plane Rewrite]
  # - Setup an allocated instance of Plane.
  #=============================================================================
  def initialize(v = nil)
    @sprite = Sprite.new(v)
    @bitmap = nil
  end

  #=============================================================================
  # Dispose [Plane Rewrite]
  # - Free an instance of Plane.
  #=============================================================================
  def dispose
    @sprite.bitmap.dispose unless bitmap_disposed?
    @sprite.dispose unless disposed?
    return nil
  end

  #=============================================================================
  # Bitmap Disposed? [Plane Rewrite]
  #   Check whether this instance of Plane's bitmap has been freed.
  #=============================================================================
  def bitmap_disposed?
    disposed? || @sprite.bitmap.nil? || @sprite.bitmap.disposed?
  end
  
  #=============================================================================
  # Disposed? [Plane Rewrite]
  # - Check whether this instance of Plane has been freed.
  #=============================================================================
  def disposed?
    @sprite.nil? || @sprite.disposed?
  end
  
  #=============================================================================
  # OX= [Plane Rewrite]
  # - Set the offset x of this instance of Plane.
  # - val : Integer
  #=============================================================================
  def ox=(val)
    error_disposed if disposed?
    return if bitmap_disposed?
    @sprite.ox = (val % (@bitmap.nil? ? 1 : @bitmap.width))
  end
  
  #=============================================================================
  # OY= [Plane Rewrite]
  #   Set the offset y of this instance of Plane.
  #   val : Integer
  #=============================================================================
  def oy=(val)
    error_disposed if disposed?
    return if bitmap_disposed?
    @sprite.oy = (val % (@bitmap.nil? ? 1 : @bitmap.height))
  end
  
  #=============================================================================
  # Bitmap [Plane Rewrite]
  # - Get the tile bitmap of this instance of Plane.
  #=============================================================================
  def bitmap
    @bitmap
  end
  
  #=============================================================================
  # Viewport= [Plane Rewrite]
  # - Set the viewport, and refresh if the vrect has changed.
  #=============================================================================
  def viewport=(v)
    error_disposed if disposed?
    r = v.nil? ? Rect.new(0, 0, Graphics.width, Graphics.height) : v.rect
    b = r != vrect
    ret = @sprite.viewport = v
    self.bitmap = @bitmap if b
    return ret
  end
  
  #=============================================================================
  # Bitmap= [Plane Rewrite]
  # - Set the tile bitmap of this instance of Plane.
  # - bmp : Bitmap
  #=============================================================================
  def bitmap=(bmp)
    error_disposed if disposed?
    if bmp.nil?
      @sprite.bitmap = nil
      return @bitmap = nil
    end
    w, h = vrect.width, vrect.height
    nw = bmp.width <= 100 ? 2 : 3
    nh = bmp.height <= 100 ? 2 : 3
    dx = [(w / bmp.width).ceil, 1].max * nw
    dy = [(h / bmp.height).ceil, 1].max * nh
    bw = dx * bmp.width
    bh = dy * bmp.height
    @bitmap = bmp
    key = [vrect.to_a, bmp.name]
    if Cache.has_plane?(key)
      @sprite.bitmap = Cache.plane(key)
    else
      @sprite.bitmap = Bitmap.new(bw, bh)
     
      dx.times do |x|
        dy.times do |y|
          @sprite.bitmap.blt(x * bmp.width, y * bmp.height,@bitmap,@bitmap.rect)
        end
      end
      Cache.add_plane(key, @sprite.bitmap)
    end
  end
  
  #=============================================================================
  # Method Missing [Plane Rewrite]
  # - Here we let any methods not found in this class be redirected to our
  #   underlying sprite.
  #=============================================================================
  def method_missing(sym, *argv, &argb)
    if @sprite.respond_to?(sym)
      error_disposed if disposed?
      return @sprite.send(sym, *argv, &argb)
    end
    super(sym, *argv, &argb)
  end

  private
  #=============================================================================
  # Error Disposed [Plane Rewrite]
  # - If this plane (and it's underlying sprite) has been freed, then throw an
  #   RGSSError describing a disposed Plane.
  #=============================================================================
  def error_disposed
    raise RGSSError, 'disposed Plane', caller
  end

  #=============================================================================
  # Vrect [Plane Rewrite]
  # - Get the view rect of this instance of Plane, which depends on if the
  #   viewport has been set or not.
  #=============================================================================
  def vrect
    @sprite.viewport.nil? ? Rect.new(0, 0, Graphics.width, Graphics.height) : 
    @sprite.viewport.rect
  end
end

#===============================================================================
# Spritesheet Map
#===============================================================================
class Spriteset_Map
  #=============================================================================
  # Update Parallax
  #=============================================================================
  def update_parallax
    if @parallax_name != $game_map.parallax_name
      @parallax_name = $game_map.parallax_name
      @parallax.bitmap.dispose if @parallax.bitmap &&
      !Cache.plane_cache.value?(@parallax.bitmap)
      @parallax.bitmap = Cache.parallax(@parallax_name)
      Graphics.frame_reset
    end
    @parallax.ox = $game_map.parallax_ox(@parallax.bitmap)
    @parallax.oy = $game_map.parallax_oy(@parallax.bitmap)
  end
end
end

#===============================================================================
#   ►►►                      BEGIN NEW SEGMENT                         ◄◄◄
#   ►►►                     Map Name on Load Fix                       ◄◄◄
#===============================================================================
if BWX_BF::BGFX_MNOLF
#===============================================================================
# Window Map Name
#===============================================================================
class Window_MapName < Window_Base
  #=============================================================================
  # Reinitialize [Map Name on Load Fix]
  #=============================================================================
  alias bugfix_wmn_init initialize
  def initialize
    bugfix_wmn_init
    if $game_map.display_name
	  self.contents_opacity = 255
	  @show_count = 150
    end
  end

  #=============================================================================
  # Draw background [Map Name on Load Fix]
  #=============================================================================
  def draw_background(rect)
    temp_rect = rect.clone
    temp_rect.width /= 2
    contents.gradient_fill_rect(temp_rect, back_color2, back_color1)
    temp_rect.x = temp_rect.width
    contents.gradient_fill_rect(temp_rect, back_color1, back_color2)
  end

  #=============================================================================
  # Refresh [Map Name on Load Fix]
  #=============================================================================
  def refresh
    contents.clear
    unless $game_map.display_name.empty?
      draw_background(contents.rect)
      draw_icon(15, 0, 0)
      draw_text(contents.rect, $game_map.display_name, 1)
    end
  end
end
end
#===============================================================================
# EOF
#===============================================================================
end # End Activation Handler
