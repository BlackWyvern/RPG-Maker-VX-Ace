=begin
#===============================================================================
  Black Wyvern Arts - RPGMaker-X Sleeker Gauges
  Author: Black Wyvern
  Created: 02/01/16
  Updated: 03/13/16
  Version: 1.51
#===============================================================================
  *** Only for RPG Maker VX Ace. ***
  ------------------------------------------------------------------------------
  To install this script, open up your script editor and copy/paste this script
  to an open slot below ▼ Materials but above ▼ Main. Remember to save.
  
  Terms of use:
    1. Give credit where credit is due.
    2. You may use my code in anything you like. Commercial, non-commercial.
    3. If you edit my code in any way, please link back to the original source.
    4. Support is always appreciated in form of gold, sacrificial virgins,
        large quantaties of bacon (or other cooked meats), or free games.
          I can be contacted at LuneTheWyvern@Gmail.com

  Description:
    Changes the appearance and function of gauges throughout
    the game automatically. Can be modded to allow for custom gauge
    definitions.
  
  Configuration:
    Options below allow for customization.
  
  Instructions: Plug 'n' Play
    This script redefines the vanilla gauge styles, so unless you have something
    else that changes their appearance or function, this script will seamlessly
    integrate.
    
    To draw actor HP gauge:
    draw_actor_hp(actor, x, y, [width = 124, pos = :def, mode = :dyn,
      height = BWX::Vars::BARHEIGHT, style = "", notext = false,
      hidden = false,notag = false])
    
    The parameters width, style, height, pos, mode, notext, hidden and notag
      are optional.
    width   How big your bar is. Don't make it too big, or it wont fit. TWSS :F
    pos     Can be :def, :up, :down. This is the position of the gauge text.
    mode    Is :dyn or :static. This determines the bar update behavior.
    height  Is if you wish to use a custom bar height.
    style   The style of the gauge if you wish to use something other than def.
    notext  Disables gauge text.
    hidden  Disables the gauge from drawing until it has values assigned to it.
    notag   Does not draw the vocab abbreviation, only if notext is false.
    
    To draw a custom gauge:
    draw_gauge(x, y, width, rate, col1, col2, [pos = :def,
      height = BWX::Vars::BARHEIGHT, style = "", hidden = false])
    - optionally -
    @gauges[[x,y]].extras(title,current,max,type,mode,notext,notag)
    - or -
    @gauges[[x,y]].gtype(type,mode)
    
    Using gtype will allow you to set a static gauge without in-built text
    display. Using set_extra will allow you to set text and type simultaniously.
    Don't use both. Either or.
    
    For experienced users:
    eval_gauge(x, y, width, eval_rate, eval_col1, eval_col2, eval_text = "",
      pos = :def, mode = :dyn, height = BWX::Vars::BARHEIGHT, style = "",
      notext = false, hidden = false)

    This will render a gauge that will evaluate the given formulas for bar
    rate, color and display text.
    Use the internal handles for the gauge definitions. EG: @cur_rate, ect...

    ►►► BIG NOTICE YOU SHOULD PROBABLY READ ◄◄◄
    Animating these gauges becomes very laggy, very quickly.
    
    It is strongly advised that if you use a lot of them at once, to set the
    mode to :static, or set the STATIC options for all gauges below. If you do
    chose to have many gauges at once, as long as you only update 4-5 of them
    at once, the impact should be negligable. Using the || style will also
    drastically reduce process time.
    
    Additionally, if your gauges have text assigned to them, and are not set to
    :static mode, you will need to be careful on how you position your bars.
    The gauges use clear_rect to erase the text before redrawing it. This will
    nuke fill_rect backgrounds, or other bars if placed in overlap with the text
    areas. I've done what I can to minimize this effect, but if you see
    text/bars getting cut off, you will need to move them around.
    
    ►►► MODDING INFORMATION ◄◄◄
    Because everyone loves bars, here's how to make your own. Remember to change
    variable names so you can keep things neat and orderly.

#===============================================================================
# BWX Custom Bar Style
#===============================================================================
module BWX
  module Vars
    CUSTSTYLE = "||"
  end
end

#===============================================================================
# Sleeker Guages Window Base
#===============================================================================
class Window_Base < Window
  #=============================================================================
  # Alias: Get Gauge Style
  #=============================================================================
  alias custom_ggs gauge_style
  def gauge_style(type)
    case type
      when "custom";  return BWX::Vars::CUSTSTYLE
    end
    custom_ggs(type)
  end
  
  #=============================================================================
  # Draw Custom Bar (Change this to whatever you want)
  #=============================================================================
  def draw_custom_gauge(actor,x,y,width=124,pos=:def,mode=:dyn,
    height=BWX::Vars::BARHEIGHT,style="",notext=false,hidden=false,notag=false)

    type = "custom"; style = gauge_style(type) if style.empty?
    rate = actor.custom_rate
    if BWX::Vars::REALTIMEFLAGS.include?(type)
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,width,rate,Custom_Colors(1,rate),Custom_Colors(2,rate),
      pos,height,style,hidden)
    @gauges[[x,y]].extras("title",current_val,max_val,type,mode,notext,notag)
  end
end

#===============================================================================
# BWX Custom Bar Definition
#===============================================================================
module BWX_CustomBarDefinition
  #=============================================================================
  # Custom Colors (Change this to whatever you want)
  #=============================================================================
  def Custom_Colors(position, rate)
    case position
    
    #Here's where you need to read a bit. There's three different things you can
    #do here. But what you need to keep in mind is that Color1 is the left side
    #and Color2 is the right side, and the two are blended into a gradient.
    
    #Method 1: Manual Dynamic Color
    #This gives you the most control, but you do need to understand how rates
    #work. In this example.. The bar goes from 80,0,0 to 255,0,0 when full and
    #0,150,150 to 0,255,255 when empty. This means it will go from dark red to
    #a bright cyan as it increases.
    
    when 1; return Color.new(0+(80*(1-rate)),(150*rate),(150*rate),192)
    when 2; return Color.new(0+(255*(1-rate)),(255*rate),(255*rate),192)
    
    #Method 2: Automatic Dynamic Color
    #You can set an autormatic dynamic color, which will work similarly as the
    #above. This one however, is slightly easier to define.
    
    when 1; return Auto_Color(<Left color when full>,
                              <Left color when empty>),rate)
    when 2; return Auto_Color(<Right color when full>,
                              <Right color when empty>,rate)

    #Method 3: Static Colors
    #You could also just set static text colors. If you chose to use this route,
    #you do not need the next section of code for this particular bar. You can
    #add it in if you want... But it won't do anything.
    
    when 1; return text_color(1)
    when 2; return text_color(2)
    end
  end
end
include BWX_CustomBarDefinition

class Sleek_Gauge
  #=============================================================================
  # Alias: Refresh (Change this to whatever you set the definition to.)
  #=============================================================================
  alias custom_refresh refresh
  def refresh
    case @type
    when "custom"
      @color1 = Custom_Colors(1,@cur_rate)
      @color2 = Custom_Colors(2,@cur_rate)
    end
    custom_refresh
  end
end

    ►►► END OF MODDING INFORMATION (Have fun!)◄◄◄

  Optional:
    - BWA RPGM-X Enemy HP Bars, Place this above EHPB, it makes it look bettter.

  Dependencies:
    - None
  
  Compatability:
    - BWA RPGM-X Core
    - Yanfly Battle Engine
  
  Credits:
    - Vlue :: Sleek Gauges
    - Syvkal :: Menu Gauges
    - Moghunter :: For having an ATB gauge that shows all the formulas.
#===============================================================================
=end

active = true # Turns the script on or off.
if ($Global_Enable.nil? && active) || ($Global_Enable && active)
  ($imported||={})["RPGM-X_Gauges"]=[true,1.51]
  # ^ Signifies that the script is installed to other scripts.

#===============================================================================
# BWX Gauge Vocabulary
# -- These variables control the bar apperance.
# -- Edit them as needed.
#===============================================================================
module BWX
  module Vars
    BARHEIGHT     = 8       # Default height for bars
    STATICNUMBERS = false   # Numbers are static, or count up/down
    STATIC_GAUGES = false   # Bar has no effects between updates
    STATIC_BACKGD = false   # Background changes with bar color
    GAUGEMOVSTYLE = :fancy  # If STATIC_GAUGES == false
                            #   use :normal, :fancy, or :fall
                            # It is not recommended to use :fall with anything
                            #   but || style.

    DOUBLEBORDERS = false   # Draws two pixel borders if true. Else, only one.

    MULTIPLESTYLE = false   # Set true if you wish to have styles for each bar.
    
    REALTIMEFLAGS = []      # This will enable realtime rendering of specific
                            # gauge types in Yanfly Battle Engine. Enter the
                            # @type of the gauge you wish to maintain.
                            # If you are using Sleeker ATB, this will be handled
                            # for you.
    FRAMESKIPPING = 5       # This dramatically cuts down on rendering lag, but 
                            # also makes bar animations look slightly choppy.
                            # Try to keep it under 10. This will only update the
                            # gauge movements once every x update calls.
                            # Also appliies to popups in YEA Battle Engine.
    #===========================================================================
    # Available Styles = (   )   <   >   |   /   \
    # -- Will use DEFSTYLE for all the bars, unless MULTIPLESTYLE is true.
    # -- If using \, you will need to use two per side. So \\\\ for a double.
    #===========================================================================
    DEFSTYLE = '//'         # Style to use default
    HP_STYLE = '||'         # Style of the HP Gauge
    MP_STYLE = '||'         # Style of the MP Gauge
    TP_STYLE = '||'         # Style of the TP Gauge
    XP_STYLE = '||'         # Style of the XP Gauge
    LVLSTYLE = '||'         # Style of the Level Gauge
    EVLSTYLE = '||'         # Style of the Eval Gauge
    PARSTYLE = '||'         # Style of the Parameter Gauges
    #===========================================================================
    # Control the colours of the gauge borders and shading
    #===========================================================================
    BAR_COL1 = Color.new(0, 0, 0, 192)        # Outer Border
    BAR_COL2 = Color.new(255, 255, 192, 192)  # Inner Border
    BAR_COL3 = Color.new(0, 0, 0, 12)         # Half of Inner Shading
    BAR_COL4 = Color.new(64, 0, 0, 92)        # Half of Inner Shading
  end
end

#===============================================================================
# BWX Bar Definitions
#===============================================================================
module BWX
  module SleekGauges
    #===========================================================================
    # Param_Color
    # -- Color for base param gauges
    #===========================================================================
    def Param_Color(param_id, position)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case param_id
            when 2; return position == 1 ? text_color(16) : text_color(17)
            when 3; return position == 1 ? text_color(18) : text_color(19)
            when 4; return position == 1 ? text_color(20) : text_color(21)
            when 5; return position == 1 ? text_color(22) : text_color(23)
            when 6; return position == 1 ? text_color(24) : text_color(25)
            when 7; return position == 1 ? text_color(26) : text_color(27)
          end
        end
      end
      case param_id
        when 2; return position == 1 ? text_color( 2) : text_color( 2) # ATK
        when 3; return position == 1 ? text_color(10) : text_color(10) # DEF
        when 4; return position == 1 ? text_color( 5) : text_color( 5) # MAT
        when 5; return position == 1 ? text_color(13) : text_color(13) # MDF
        when 6; return position == 1 ? text_color( 3) : text_color( 3) # AGI
        when 7; return position == 1 ? text_color( 6) : text_color( 6) # LUK
      end
    end

    #===========================================================================
    # HPColor
    # -- Color for HP gauges
    #===========================================================================
    def HP_Colors(position, rate)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case position
            when 1; return Auto_Color(text_color(32),text_color(34),rate)
            when 2; return Auto_Color(text_color(33),text_color(35),rate)
          end
        end
      end
      case position
        when 1; return Color.new(80-(24*rate),(80*rate),(14*rate),192)
        when 2; return Color.new(240-(72*rate),(240*rate),(62*rate),192)
      end
    end

    #===========================================================================
    # MPColor
    # -- Color for MP gauges
    #===========================================================================
    def MP_Colors(position, rate)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case position
            when 1; return Auto_Color(text_color(36),text_color(38),rate)
            when 2; return Auto_Color(text_color(37),text_color(39),rate)
          end
        end
      end
      case position
        when 1; return Color.new((14*rate),80-(24*rate),(80*rate), 192)
        when 2; return Color.new((62*rate),240-(72*rate),(240*rate), 192)
      end
    end

    #===========================================================================
    # TPColor
    # -- Color for TP gauges
    #===========================================================================
    def TP_Colors(position, rate)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case position
            when 1; return Auto_Color(text_color(40),text_color(42),rate)
            when 2; return Auto_Color(text_color(41),text_color(43),rate)
          end
        end
      end
      case position
        when 1; return Auto_Color(Color.new(128,82,0,192),
                              Color.new(0,0,255,192), rate)
        when 2; return Auto_Color(Color.new(255,165,0,192), 
                                  Color.new(0,0,255,192), rate)
      end
    end

    #===========================================================================
    # XPColor
    # -- Color for XP gauges
    #===========================================================================
    def XP_Colors(position, rate)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case position
            when 1; return Auto_Color(text_color(68),text_color(70),rate)
            when 2; return Auto_Color(text_color(69),text_color(71),rate)
          end
        end
      end
      case position
        when 1; return Auto_Color(Color.new(88,147,174,255),
                              Color.new(88,147,174,255), rate)
        when 2; return Auto_Color(Color.new(133,181,203,255),
                              Color.new(133,181,203,255), rate)
      end
    end
    
    #===========================================================================
    # LVLColor
    # -- Color for Level gauges
    #===========================================================================
    def LVLColors(position, rate)
      case position
        when 1; return Color.new(0,64,256)
        when 2; return Color.new(0,64,256)
      end
    end
    
    #===========================================================================
    # Subparam_Color
    # -- Color for subparam gauges
    #===========================================================================
    def SubColors(position, rate)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          case position
            when 1; return Auto_Color(text_color(64),text_color(66),rate)
            when 2; return Auto_Color(text_color(65),text_color(67),rate)
          end
        end
      end
      case position
        when 1; return Color.new(0+(80*(1-rate)),(150*rate),(150*rate),192)
        when 2; return Color.new(0+(255*(1-rate)),(255*rate),(255*rate),192)
      end
    end

    #===========================================================================
    # Auto_Color
    # -- Will automatically create a progressive bar gradient based on two
    #    input colors and the rate of fill.
    #===========================================================================
    def Auto_Color(gradient1,gradient2,rate)
      acol = Color.new
      acol.red    = (1-rate)*gradient2.red +    rate*gradient1.red
      acol.green  = (1-rate)*gradient2.green +  rate*gradient1.green
      acol.blue   = (1-rate)*gradient2.blue +   rate*gradient1.blue
      acol.alpha  = (1-rate)*gradient2.alpha +  rate*gradient1.alpha
      return acol
    end
    
    #===========================================================================
    # Text_Color
    # -- Because this isn't a window, yo.
    #===========================================================================
    def text_color(n)
      if $imported["BWA_RPGM-X"]
        if BWX::Vars::BWX_COLOR
          row = (n / 16).to_i; col = (n % 16); off = [0,0]
          case row
            when 0 || 4 ||  8 || 12;  col.even? ? off = [0,0] : off = [3,0]
            when 1 || 5 ||  9 || 13;  col.even? ? off = [3,3] : off = [0,3]
            when 2 || 6 || 10 || 14;  col.even? ? off = [3,0] : off = [0,0]
            when 3 || 7 || 11 || 15;  col.even? ? off = [0,3] : off = [3,3]
          end
          return Cache.system(BWX::Vars::COLRSPACE).get_pixel(
            (col*4)+off[0],
            (((row/2).floor)*4)+off[1])
        end
      end
      @ColorWindow = Window_Base.new(0,0,0,0)
      color = @ColorWindow.windowskin.get_pixel(64+(n%8)*8,96+(n/8)*8)
      @ColorWindow.dispose
      return color
    end
  end
end
include BWX::SleekGauges

unless $imported["BWA_RPGM-X"]
#===============================================================================
# Vocab Module (Only if not using the RPGM-X Core)
# -- Shorthand XP
#===============================================================================
  module Vocab
    def self.xp;    "Experience"; end   # XP
    def self.xp_a;  "Exp";        end   # XP (short)
  end

#===============================================================================
#   ►►► WARNING: YOU PROBABLY SHOULDN'T EDIT ANYTHING BELOW THIS POINT ◄◄◄
#   ►►►  CUZ YEAH, THERE'S NOTHING REALLY CONFIGURABLE, AND IT DOESN'T ◄◄◄
#   ►►►              LIKE IT WHEN YOU TOUCH IT THAT WAY.               ◄◄◄
#===============================================================================

#===============================================================================
# Game Actor (Only if not using the RPGM-X Core)
# -- XP Rate for gauge calculations.
#===============================================================================
  class Game_Actor < Game_Battler
  #=============================================================================
  # XP Rate
  #=============================================================================
    def xp_rate
      a = xp_in_level
      b = xp_to_next
      return a / b if b > 0
      return 1 unless b > 0
    end
  
  #=============================================================================
  # XP To Next Level
  #=============================================================================
    def xp_to_next
      return next_level_exp - current_level_exp if level != max_level
      return 0 if level == max_level
    end

  #=============================================================================
  # XP Into This Level
  #=============================================================================
    def xp_in_level
      exp - current_level_exp
    end
  end

#===============================================================================
# Numeric Class (Only if not using the RPGM-X Core)
#===============================================================================
  class Numeric
  #=============================================================================
  # Clamp Values
  #=============================================================================
    def clamp min, max
      self < min ? min : (self > max ? max : self)
    end
  end
end # End Core Function Subs

#===============================================================================
# Game Actor
#===============================================================================
class Game_Actor < Game_Battler
  attr_accessor :actor_id
end

#===============================================================================
# Window Base
#===============================================================================
class Window_Base < Window
  attr_accessor :gauges
  attr_accessor :realtime
  
  #=============================================================================
  # Reinitialize
  #=============================================================================
  alias sg_rt_init initialize
  def initialize(*args)
    sg_rt_init(*args)
    @realtime = []
  end
  
  #=============================================================================
  # Get Gauge Style
  #=============================================================================
  def gauge_style(type)
    return BWX::Vars::DEFSTYLE if !BWX::Vars::MULTIPLESTYLE
    case type
      when "hp";  return BWX::Vars::HP_STYLE
      when "mp";  return BWX::Vars::MP_STYLE
      when "tp";  return BWX::Vars::TP_STYLE
      when "xp";  return BWX::Vars::XP_STYLE
      when "lvl"; return BWX::Vars::LVLSTYLE
      when "par"; return BWX::Vars::PARSTYLE
      when "evl"; return BWX::Vars::EVLSTYLE
    end
  end

  #=============================================================================
  # Draw Gauge
  #=============================================================================
  def draw_gauge(x,y,w,r,c1,c2,p=:def,h=BWX::Vars::BARHEIGHT,s="",hdn=false)
    s = gauge_style(s) if s.empty?
    r = r.round_to(2)
    @gauges = {} unless @gauges
    if (@gauges[[x,y]] && @gauges[[x,y]].width == w)
      @gauges[[x,y]].set_rate(r)
    else
      @gauges[[x,y]] = Sleek_Gauge.new(x,y,w,r,c1,c2,p,h,s,hdn,self)
    end
  end
  
  #=============================================================================
  # Draw Actor HP
  #=============================================================================
  def draw_actor_hp(a,x,y,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,s="",
        nt=false,hdn=false,notag=false)

    t = "hp"; s = gauge_style(t) if s.empty?; r = a.hp_rate;
    if BWX::Vars::REALTIMEFLAGS.include?(t)
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,HP_Colors(1,r),HP_Colors(2,r),p,h,s,hdn)
    @gauges[[x,y]].extras(Vocab::hp_a,a.hp,a.mhp,t,m,nt,notag)
  end
  
  #=============================================================================
  # Draw Actor MP
  #=============================================================================
  def draw_actor_mp(a,x,y,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,s="",
        nt=false,hdn=false,notag=false)

    t = "mp"; s = gauge_style(t) if s.empty?; r = a.mp_rate
    if BWX::Vars::REALTIMEFLAGS.include?(t);
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,MP_Colors(1,r),MP_Colors(2,r),p,h,s,hdn)
    @gauges[[x,y]].extras(Vocab::mp_a,a.mp,a.mmp,t,m,nt,notag)
  end
  
  #=============================================================================
  # Draw Actor TP
  #=============================================================================
  def draw_actor_tp(a,x,y,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,s="",
        nt=false,hdn=false,notag=false)

    t = "tp"; s = gauge_style(t) if s.empty?; r = a.tp_rate
    if BWX::Vars::REALTIMEFLAGS.include?(t);
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,TP_Colors(1,r),TP_Colors(2,r),p,h,s,hdn)
    @gauges[[x,y]].extras(Vocab::tp_a,a.tp,a.mtp,t,m,nt,notag)
  end
  
  #=============================================================================
  # Draw Actor XP
  #=============================================================================
  def draw_actor_xp(a,x,y,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,s="",
        nt=false,hdn=false)
        
    t = "xp"; s = gauge_style(t) if s.empty?; r = a.tp_rate
    if BWX::Vars::REALTIMEFLAGS.include?(t);
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,XP_Colors(1,r),XP_Colors(2,r),p,h,s,hdn)
    if(a.level != a.max_level)
      @gauges[[x,y]].extras(Vocab::xp_a,a.xp_in_level,a.xp_to_next,t,m,nt)
    else
      @gauges[[x,y]].extras(Vocab::xp_a,0,0,t,m,nt)
    end
  end
  
  #=============================================================================
  # Draw Actor Lvl
  #=============================================================================
  def draw_actor_lvl(a,x,y,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,s="",
        nt=false,hdn=false)

    t = "lvl"; s = gauge_style(t) if s.empty?; r = a.level.to_f / a.max_level
    if BWX::Vars::REALTIMEFLAGS.include?(t)
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,LVLColors(1,r),LVLColors(2,r),p,h,s,hdn)
    @gauges[[x,y]].extras(Vocab::level,a.level,a.max_level,t,m,nt)
  end
  
  #=============================================================================
  # Draw Sub-Param
  #=============================================================================
  def draw_subparam(a,x,y,r=0,w=124,p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,
        s="",nt=false,hdn=false,spm="SubN")
      
    s = gauge_style("par") if s.empty?;
    if BWX::Vars::REALTIMEFLAGS.include?(spm) 
        @realtime+=[[x,y,a]] unless @realtime.include?([x,y,a]); end
    draw_gauge(x,y,w,r,SubColors(1,r),SubColors(2,r),p,h,s,hdn)
    @gauges[[x,y]].gtype(spm,m)
  end
  
  #=============================================================================
  # Draw Eval Gauge
  #=============================================================================
  def eval_gauge(x,y,w,r,ec1,ec2,et="",p=:def,m=:dyn,h=BWX::Vars::BARHEIGHT,
        s="",nt=false,hdn=false)
      
    s = gauge_style("evl") if s.empty?;
    draw_gauge(x,y,w,r,ec1,ec2,p,h,s,hdn)
    @gauges[[x,y]].extras(et,0,0,"eval",m,nt)
  end
  
  #=============================================================================
  # Update Gauges
  #=============================================================================
  alias gauge_update update
  def update
    gauge_update
    if @gauges
      @gauges.each {|k,gauge| gauge.update}
    end
  end
end

#===============================================================================
# Sleek_Gauge
#===============================================================================
class Sleek_Gauge
  attr_accessor :x
  attr_accessor :y
  attr_accessor :width
  attr_accessor :cur_rate
  attr_accessor :pos
  attr_accessor :mode
  attr_accessor :height
  attr_accessor :style
  attr_accessor :notext
  attr_accessor :hidden
  attr_accessor :notag
  attr_accessor :type
  attr_accessor :cur_val
  attr_accessor :latch
  #=============================================================================
  # Initialize
  #=============================================================================
  def initialize(x,y,w,r,c1,c2,p,h,s,hdn,win)
    @x = x; @y = y
    @width = w
    @cur_rate = @max_rate = r.is_a?(String) ? eval(@eval_rate = r) : r
    @color1 = c1; @color2 = c2
    @pos = p; @window = win
    @speed = @speed_rate = 0
    @height = h; @fall_sprites = []
    @style = s; @mode = :dyn; @hidden = hdn
    @color1 = eval(@eval_col1 = @color1) if @color1.is_a?(String)
    @color2 = eval(@eval_col2 = @color2) if @color2.is_a?(String)
    @latch = false; @frame = -1
  end
  
  #=============================================================================
  # Update
  #=============================================================================
  def update
    if BWX::Vars::FRAMESKIPPING != 0
      @frame += 1
      return unless @frame % BWX::Vars::FRAMESKIPPING == 0
      @frame = 0 if @frame > 100
    end
    update_fall_sprites if !@fall_sprites.empty?
    @cur_rate; @max_rate
    @cur_val; @set_val
    return if (@cur_rate == @max_rate && @cur_val == @set_val)
    @cur_rate -= @speed_rate if @cur_rate > @max_rate
    @cur_rate += @speed_rate if @cur_rate < @max_rate
    @cur_rate = @max_rate if (@cur_rate - @max_rate).abs < @speed_rate
    @cur_rate = @max_rate if
      (BWX::Vars::STATIC_GAUGES || BWX::Vars::GAUGEMOVSTYLE == :fall)
    unless @vocab.empty? || @notext
      @cur_val -= @speed if @cur_val > @set_val
      @cur_val += @speed if @cur_val < @set_val
      @cur_val = @set_val if (@cur_val-@set_val).abs < @speed
      @cur_val = @set_val if BWX::Vars::STATICNUMBERS
      @cur_val = @set_val if @max_val == 0
    end
    refresh
  end

  #=============================================================================
  # Update :fall Sprites
  #=============================================================================
  def update_fall_sprites
    @fall_sprites.each do |sprite|
      sprite.y += 1 if sprite.opacity < 175
      sprite.y -= 1 if sprite.opacity > 175
      if !@window.viewport.nil?
        xx = @window.x + @window.padding +
          @window.viewport.rect.x - @window.viewport.ox
      else
        xx = @window.x + @window.padding;yy = @window.y + @window.padding
      end
      sprite.x = xx + @x + @width * @max_rate
      sprite.opacity -= 5
      sprite.dispose if sprite.opacity == 0
    end
    @fall_sprites = @fall_sprites.select {|sprite| !sprite.disposed? }
  end

  #=============================================================================
  # Refresh
  #=============================================================================
  def refresh
    return if (@hidden && @cur_rate == 0) &&
      ((@set_val.nil? && @max_val.nil?) || (@set_val == 0 && @max_val == 0))
    if !@latch
      @vocab.nil? ? @vocab = "" : @vocab
      txrec = @window.text_size(@vocab) unless @type == "eval"
      txrec = @window.text_size(
        eval(@vocab.gsub(/((\e)|(\i))([A-Z]+)(\[\d\])/,""))) if @type == "eval"
      txrec.height -= 4
      y = @y
      (y -= txrec.height/2.0) if @pos == :def
      (y -= txrec.height/1.5) if @pos == :up
      (y += @height-2) if @pos == :down

      if @mode == :dyn && @width > 100 && !@notag && !@notext
        rect1=Rect.new(@x,y,txrec.width,txrec.height) if@pos == :def
        rect1=Rect.new(@x,y,txrec.width,txrec.height) if@pos == :up
        rect1=Rect.new(@x,y,txrec.width,txrec.height) if@pos == :down
        @window.contents.clear_rect(rect1)
      end
      
      @display.nil? ? @display = "" : @display
      txrec = @window.text_size(@display)
      xr = @x + @width - txrec.width
      txrec.height -= 4
      if @mode == :dyn && !@notext
        rect2=Rect.new(xr,y,txrec.width,txrec.height) if @pos == :def
        rect2=Rect.new(xr,y,txrec.width,txrec.height) if @pos == :up
        rect2=Rect.new(xr,y,txrec.width,txrec.height) if @pos == :down
        @window.contents.clear_rect(rect2) if @type != "eval"
      end
      
      case @type
      when "hp"
        @color1 = HP_Colors(1,@cur_rate)
        @color2 = HP_Colors(2,@cur_rate)
      when "mp"
        @color1 = MP_Colors(1,@cur_rate)
        @color2 = MP_Colors(2,@cur_rate)
      when "tp"
        @color1 = TP_Colors(1,@cur_rate)
        @color2 = TP_Colors(2,@cur_rate)
      when "xp"
        @color1 = XP_Colors(1,@cur_rate)
        @color2 = XP_Colors(2,@cur_rate)
      when "lvl"
        @color1 = LVLColors(1,@cur_rate)
        @color2 = LVLColors(2,@cur_rate)
      when "Sub%", "SubN"
        @color1 = SubColors(1,@cur_rate)
        @color2 = SubColors(2,@cur_rate)
      when "eval"
        @color1 = eval(@eval_col1)
        @color2 = eval(@eval_col2)
      end
      @cur_rate = @cur_rate.clamp 0,1
      @max_rate = @max_rate.clamp 0,1
      
      draw_gauge(@x,@y,@width,@cur_rate,@color1,@color2,@style,@height)
      draw_text(@x,@y,@width) unless @notext
    end
    @latch = false
    @latch = true if BWX::Vars::REALTIMEFLAGS.include?(@type) && @cur_rate == 1
  end

  #=============================================================================
  # Set Rate
  #=============================================================================
  def set_rate(rate)
    reset_speed = rate != @max_rate
    @max_rate = rate
    
    movetime = 60.0
    movetime /= BWX::Vars::FRAMESKIPPING if BWX::Vars::FRAMESKIPPING != 0
    
    @speed_rate = (@cur_rate-@max_rate).abs / (movetime) if reset_speed
    if BWX::Vars::GAUGEMOVSTYLE == :fall && reset_speed
      if @cur_rate > @max_rate
        sprite = Sprite.new()
        if !@window.viewport.nil?
          xx = @window.x + @window.padding +
            @window.viewport.rect.x - @window.viewport.ox
          yy = @window.y + @window.padding +
            @window.viewport.rect.y - @window.viewport.oy
        else
          xx = @window.x + @window.padding
          yy = @window.y + @window.padding
        end
        sprite.x = xx + @x + @width * @max_rate
        sprite.y = yy + @y + @window.line_height - @height
        sprite.z = @window.z + 1
        width = (@width * @cur_rate).to_i - (@width * @max_rate).to_i
        if width > 1
          sprite.bitmap = Bitmap.new(width,@height-2)
          sprite.bitmap.gradient_fill_rect(sprite.bitmap.rect,@color1,@color2)
          @fall_sprites.push(sprite)
        else
          sprite.dispose
        end
      end
    end
    refresh
  end

  #=============================================================================
  # Set Type		
  #=============================================================================
  def gtype(type, mode = :dyn)		
    @type = type		
    @mode = mode	
  end
  
  #=============================================================================
  # Set Extra Params
  #=============================================================================
  def extras(vocab,set_val,max_val=0,type="",mode=:dyn,notext=false,notag=false)
    @type = type
    @mode = mode
    @notag = notag
    @notext = notext

    @vocab = vocab
    @max_val = max_val
    set_val = set_val
    reset_speed = set_val != @set_val
    if @cur_val
      @set_val = set_val
    else
      @cur_val = set_val
      @set_val = set_val
    end
    movetime = 60.0
    movetime /= BWX::Vars::FRAMESKIPPING if BWX::Vars::FRAMESKIPPING != 0
    @speed = (@cur_val-@set_val).abs / (movetime) if reset_speed
    @speed = 1 if @speed == 0

    update
  end
  
  #=============================================================================
  # Draw Gauge Text
  #=============================================================================
  def draw_text(x, y, w)
    return unless @cur_val
    
    txrec = @window.text_size(@vocab) unless @type == "eval"
    txrec = @window.text_size(
      eval(@vocab.gsub(/((\e)|(\i))([A-Z]+)(\[\d\])/,""))) if @type == "eval"
    txrec.height = 18 if txrec.height == 0
    (y -= txrec.height/2.0) if @pos == :def
    (y -= txrec.height/1.5) if @pos == :up
    (y += @height-3) if @pos == :down
    @vocab.nil? ? @vocab = "" : @vocab
    
    if w > 100 && !@notag && !@notext
      @window.change_color(@window.system_color)
      @window.draw_text(x,y,txrec.width,txrec.height,@vocab) if
        @type != "eval"
      @window.draw_text_ex(x,y,eval(@vocab)) if @type == "eval"
      @window.change_color(
        ((@cur_val < @max_val / 4) && (@type == "hp" || @type == "sp")) ? 
          @window.crisis_color : @window.normal_color)
      return if @type == "eval"
    end
    if w > 80
      if(@max_val != 0)
        @display = @cur_val.to_i.group + "/" + @max_val.to_i.group
      else
        @display = @cur_val.to_i.group
        case @type
          when "xp"; @display = "Max "+Vocab::level_a
          when "Sub%"; @display += "%"
          else; @display = "" if @cur_val == 0
        end
      end
    else
      if(@max_val == 0)
        @display = ""
        @display = "Max "+Vocab::level_a if @type == "xp"
      else
        @display = @cur_val.to_i.group
      end
    end
    
    txrec = @window.text_size(@display)
    xr = x + w - txrec.width
    @window.draw_text(xr,y,txrec.width,txrec.height,@display,2) unless @notext
    @window.change_color(@window.normal_color)
  end
  
  #=============================================================================
  # Draw Gauge
  #=============================================================================
  def draw_gauge(x, y, width, rate, color1, color2,
      style = BWX::Vars::DEFSTYLE, height = BWX::Vars::BARHEIGHT)
    x+=4
    fill_ww = (width * @max_rate).to_i
    h = height.to_i

    style.slice!(/\s*/); style = style.split(/\s*/)
    
    if(BWX::Vars::STATIC_BACKGD)
      backcol1 = BWX::Vars::BAR_COL3
      backcol2 = BWX::Vars::BAR_COL4
    else
      backcol1 = Color.new(color1.red,color1.green,color1.blue,12)
      backcol2 = Color.new(color2.red,color2.green,color2.blue,92)
    end

    # Square Style
    if style.empty? or (style[0] == "|" && style[1] == "|")
      fill_w = ((width-4) * rate).round
      fill_ww = ((width-4) * @max_rate).round
      if(BWX::Vars::DOUBLEBORDERS)
        @window.contents.fill_rect(x-2,y-2,width  ,h+4,BWX::Vars::BAR_COL1)
        @window.contents.fill_rect(x-1,y-1,width-2,h+2,BWX::Vars::BAR_COL2)
      else
        @window.contents.fill_rect(x-1,y-1,width-2,h+2,BWX::Vars::BAR_COL1)
      end
      @window.contents.gradient_fill_rect(x,y,width-4,h,backcol1, backcol2)
      
      if rate != @max_rate
        case BWX::Vars::GAUGEMOVSTYLE
          when :fancy
            color1.alpha -= 50; color2.alpha -= 50
            if rate > @max_rate
              @window.contents.gradient_fill_rect(x,y,fill_w,h,color1,color2)
              color1.alpha += 50; color2.alpha += 50
              @window.contents.gradient_fill_rect(x,y,fill_ww,h,color1,color2)
            else rate < @max_rate
              @window.contents.gradient_fill_rect(x,y,fill_ww,h,color1,color2)
              color1.alpha += 50; color2.alpha += 50
              @window.contents.gradient_fill_rect(x,y,fill_w,h,color1,color2)
            end
          when :normal
            @window.contents.gradient_fill_rect(x,y,fill_w,h,color1,color2)
          when :fall
            if rate > @max_rate
              @window.contents.gradient_fill_rect(x,y,fill_ww,h,color1,color2)
            else
              @window.contents.gradient_fill_rect(x,y,fill_w,h,color1,color2)
            end
        end
      else
        @window.contents.gradient_fill_rect(x,y,fill_w,h,color1,color2)
      end
    else # Dynamic Generation
      adj1 = style_adj_string(style[0]); adj2 = style_adj_string(style[1], true)

      if(BWX::Vars::DOUBLEBORDERS)
        h += 4
        for i in 0...h
          a1 = eval(adj1[0]); a2 = eval(adj2[0])
          a3 = adj1[2]; a4 = adj2[4].nil? ? adj2[2] : adj2[4]
          @window.contents.fill_rect(
            x-a3+a1,y-2+i,width+(a3+a4)-a1-a2,1,
            BWX::Vars::BAR_COL1)
        end
      
        h -= 2
        for i in 0...h
          a1 = eval(adj1[0]); a2 = eval(adj2[0])
          a3 = adj1[1]; a4 = adj2[3].nil? ? adj2[1] : adj2[3]
          @window.contents.fill_rect(
            x-a3+a1,y-1+i,width+(a3+a4)-a1-a2,1,
            BWX::Vars::BAR_COL2)
        end
      else
        h += 2
        for i in 0...h
          a1 = eval(adj1[0]); a2 = eval(adj2[0])
          a3 = adj1[1]; a4 = adj2[3].nil? ? adj2[1] : adj2[3]
          @window.contents.fill_rect(
            x-a3+a1,y-1+i,width+(a3+a4)-a1-a2,1,
            BWX::Vars::BAR_COL1)
        end
      end
      
      h -= 2
      for i in 0...h
        a1 = eval(adj1[0]); a2 = eval(adj2[0])
        @window.contents.gradient_fill_rect(
          x+a1,y+i,width-a1-a2,1,
          backcol1,backcol2)
      end
      
      for i in 0...h
        a1 = eval(adj1[0]); a2 = eval(adj2[0])
        
        # Rate inaccuracy fix...
        fill_w = ((width-a1-a2) * rate).round
        fill_ww = ((width-a1-a2) * @max_rate).round
        
        if rate != @max_rate
          case BWX::Vars::GAUGEMOVSTYLE
            when :fancy
              color1.alpha -= 50; color2.alpha -= 50
              if rate > @max_rate
                @window.contents.gradient_fill_rect(x+a1,y+i,fill_w,1,
                  color1,color2)
                color1.alpha += 50; color2.alpha += 50
                @window.contents.gradient_fill_rect(x+a1,y+i,fill_ww,1,
                  color1,color2)
              else rate < @max_rate
                @window.contents.gradient_fill_rect(x+a1,y+i,fill_ww,1,
                  color1,color2)
                color1.alpha += 50; color2.alpha += 50
                @window.contents.gradient_fill_rect(x+a1,y+i,fill_w,1,
                  color1,color2)
              end
            when :normal
              @window.contents.gradient_fill_rect(x+a1,y+i,fill_w,1,
                color1,color2)
            when :fall
              if rate > @max_rate
                @window.contents.gradient_fill_rect(x,y+1,fill_ww,1,
                  color1,color2)
              else
                @window.contents.gradient_fill_rect(x,y+1,fill_w,1,
                  color1,color2)
              end
          end
        else
          @window.contents.gradient_fill_rect(x+a1,y+i,fill_w,1,color1,color2)
        end
      end
    end
  end
  
  #=============================================================================
  # Style Adjective Strings
  #=============================================================================
  def style_adj_string(sym, edge = false) 
    case sym
      # Confusing as all hell, so you shouldn't touch this. Thanks Syvkal.
    when '/'
      [(edge ? 'i+6' : '(h-1) - i'), 3, 5]
    when '\\'
      [(edge ? '(h-1) - i+6' : 'i'), 3, 5]
    when '<'
      [(edge ? '(h/2)-((h/2) - i).abs+5' : '((h/2) - i).abs'), 2, 3]
    when '>'
      [(edge ? '((h/2) - i).abs+5' : '(h/2)-((h/2) - i).abs-3'), 2, 3]
    when '('
      [(edge ? '((h/2) * Math.sin(i * 1.0 * Math::PI / (h-1))).round.to_i+5' :
        '(h-6) - ((h/2) * Math.sin(i * 1.0 * Math::PI / (h-1))).round.to_i'), 
        3, 5, 3, 5]
    when ')'
      [(edge ? '(h-3)-((h/2)*Math.sin(i*1.0*Math::PI/(h-1))).round.to_i+5' :
        '((h/2) * Math.sin(i * 1.0 * Math::PI / (h-1))).round.to_i+1'), 
        3, 5, 3, 5]
    else # eg. | or invalid sym
      ['0', 1, 2]
    end
  end
end

#===============================================================================
# Yanfly Battle Engine Compatability
#===============================================================================
if $imported["YEA-BattleEngine"]
#===============================================================================
# Sprite Popup
#===============================================================================
class Sprite_Popup < Sprite_Base
  #=============================================================================
  # Reinitialize
  #=============================================================================
  alias satb_sp_init initialize
  def initialize(*args)
    satb_sp_init(*args)
    @frame = -1
    @fade = YEA::BATTLE::POPUP_SETTINGS[:fade] * (BWX::Vars::FRAMESKIPPING*2)
    @full = YEA::BATTLE::POPUP_SETTINGS[:full] / (BWX::Vars::FRAMESKIPPING*2)
  end
  
  #=============================================================================
  # Update
  #=============================================================================
  def update
    if BWX::Vars::FRAMESKIPPING != 0
      @frame += 1
      return unless @frame % BWX::Vars::FRAMESKIPPING*2 == 0
      @frame = 0 if @frame > 100
    end
    super
    #---
    if @flags.include?("critical") && YEA::BATTLE::FLASH_CRITICAL
      @hue_duration = 2 if @hue_duration == nil || @hue_duration == 0
      @hue_duration -= 1
      self.bitmap.hue_change(15) if @hue_duration <= 0
    end
    #---
    if @zoom_direction == "up"
      self.zoom_x = [self.zoom_x + 0.075, @target_zoom].min
      self.zoom_y = [self.zoom_y + 0.075, @target_zoom].min
    else
      self.zoom_x = [self.zoom_x - 0.075, @target_zoom].max
      self.zoom_y = [self.zoom_y - 0.075, @target_zoom].max
    end
    #---
    @full -= 1
    return if @full > 0
    self.y -= 1
    self.opacity -= @fade
  end
end

#===============================================================================
# Window Gauge Pane
#===============================================================================
class Window_GaugePane < Window_Selectable
  #=============================================================================
  # Initialize
  #=============================================================================
  def initialize(x,y,w,h)
    super(x,y,w,h)
    self.openness = 0
    @frame = -1
  end
  
  #=============================================================================
  # String to Boolean
  #=============================================================================
  def to_b(string)
    string == "true"
  end
  
  #=============================================================================
  # Realtime Update Area
  #=============================================================================
  def update
    super
    return if self.openness != 255
      
    for gauges in @gauges
      for item in gauges
        next if item.class != Sleek_Gauge
        next if !BWX::Vars::REALTIMEFLAGS.include?(item.type)
        for entry in @realtime
          next unless [item.x,item.y] == entry[0,2]
          a = entry[2]
          case item.type
            when "SubN", "Sub%"
              initializer = "draw_subparam("
              @values = [a,item.x,item.y,item.cur_rate,item.width,
              item.pos.to_sym,item.mode.to_sym,item.height,
              item.style,to_b(item.notext.to_s),to_b(item.hidden.to_s),
              item.type]
              @formatted=initializer+"(*@values)"
            when "atb", "datb"
              if $imported["RPGM-X_Sleek_ATB"]
              fetch_atb_system(
                a,item.x,item.y,item.width,item.pos.to_sym,item.mode.to_sym,
                item.height,item.style,to_b(item.notext.to_s),
                to_b(item.hidden.to_s))
              end
            else
              initializer = "draw_actor_"+item.type
              @values = [a,item.x,item.y,item.width,item.pos.to_sym,
                item.mode.to_sym,item.height,item.style,
                to_b(item.notext.to_s),to_b(item.hidden.to_s)]
              @formatted=initializer+"(*@values)"
          end
          eval(@formatted) if @formatted
        end
      end
    end
  end
  
  #=============================================================================
  # Draw Item
  #=============================================================================
  def draw_item(index)
    actor = battle_members[index]
    return if actor.nil?
    rect = item_rect(index)
    sx = rect.x+2
    rw = rect.width-4
    dw = rw/2-4
    dy = line_height*3+3
    contents.font.size = YEA::BATTLE::BATTLESTATUS_TEXT_FONT_SIZE
    
    if (draw_tp?(actor) && draw_mp?(actor))
      draw_actor_tp(actor, sx,    dy, dw, :down)
      draw_actor_mp(actor, sx+dw, dy, dw, :down)
    elsif (draw_tp?(actor) && !draw_mp?(actor))
      draw_actor_tp(actor, sx,    dy, rw, :down)
    elsif (!draw_tp?(actor) && draw_mp?(actor))
      draw_actor_mp(actor, sx,    dy, rw, :down)
    end
    draw_misc_gauges(actor,index,sx,rw)
  end

  #=============================================================================
  # Item Rect
  #=============================================================================
  def item_rect(index)
    rect = Rect.new
    rect.width = contents.width / $game_party.max_battle_members
    rect.height = contents.height
    rect.x = index * rect.width
    if YEA::BATTLE::BATTLESTATUS_CENTER_FACES
      rect.x += (contents.width - $game_party.members.size * rect.width) / 2
    end
    rect.y = 0
    return rect
  end
  
  #=============================================================================
  # Draw Misc Gauges (For easier modding)
  #=============================================================================
  def draw_misc_gauges(actor,index,sx,rw)
    draw_actor_hp(actor,sx,line_height*2+4,rw,:up)
  end
  
  #=============================================================================
  # Bunch of stuff I'm too lazy to individually tag.
  #=============================================================================
  def col_max; return $game_party.max_battle_members; end
  def battle_members; return $game_party.battle_members; end
  def actor; return battle_members[@index]; end
  def draw_tp?(actor); return actor.draw_tp?; end
  def draw_mp?(actor); return actor.draw_mp?; end
  def item_max; return $game_party.max_battle_members; end
  #def battle_members; return $game_party.battle_members; end
end
end

#===============================================================================
# Window Battle Status
#===============================================================================
class Window_BattleStatus < Window_Selectable
  if $imported["YEA-BattleEngine"]

  #=============================================================================
  # Update
  #=============================================================================
	  def update
		super
    if @SGDisplay_Window
      @SGDisplay_Window.x = self.x
      @SGDisplay_Window.y = self.y
      @SGDisplay_Window.width = self.width
      @SGDisplay_Window.height = self.height
      @SGDisplay_Window.openness = self.openness
      @SGDisplay_Window.update
    end
		return if @party == $game_party.battle_members
		@party = $game_party.battle_members.clone
		refresh
    end

  #=============================================================================
  # Alias: Refresh
  #=============================================================================
	  alias ynfbs_refresh refresh
	  def refresh
		if !@SGDisplay_Window
		  @SGDisplay_Window=Window_GaugePane.new(
        self.x,self.y,self.width,self.height)
		  @SGDisplay_Window.viewport = self.viewport
		  @SGDisplay_Window.opacity = 0
      @SGDisplay_Window.openness = self.openness
		  @SGDisplay_Window.contents.font.size =
			YEA::BATTLE::BATTLESTATUS_TEXT_FONT_SIZE
		end
		ynfbs_refresh
    end

  #=============================================================================
  # Draw Item
  #=============================================================================
    def draw_item(index)
      actor = battle_members[index]
      return if actor.nil?
      rect = item_rect(index)
      contents.clear_rect(rect)
      sx = rect.x
      sy = rect.y
      rw = rect.width-2
      dw = rw/2-2
      dy = line_height*3+3
      draw_actor_face(actor,    sx+2, sy+2, actor.alive?)
      draw_actor_name(actor,    sx,   sy, rect.width-8)
      draw_actor_action(actor,  sx,   sy)
      draw_actor_icons(actor,   sx,   line_height*1, rw)
      @SGDisplay_Window.draw_item(index)
    end
  else

  #=============================================================================
  # Draw Gauge Area (with TP) (Vanilla)
  #=============================================================================
	  def draw_gauge_area_with_tp(rect, actor)
      draw_actor_hp(actor, rect.x + 0, rect.y, 72)
      draw_actor_mp(actor, rect.x + 82, rect.y, 64)
      draw_actor_tp(actor, rect.x + 156, rect.y, 64)
	  end

  #=============================================================================
  # Draw Gauge Area (without TP) (Vanilla)
  #=============================================================================
	  def draw_gauge_area_without_tp(rect, actor)
      draw_actor_hp(actor, rect.x + 0, rect.y, 134)
      draw_actor_mp(actor, rect.x + 144,  rect.y, 76)
	  end
  end

  #=============================================================================
  # Draw Actor Name
  #=============================================================================
  def draw_actor_name(actor, dx, dy, dw = 112)
    reset_font_settings
    contents.font.size = YEA::BATTLE::BATTLESTATUS_NAME_FONT_SIZE
    change_color(hp_color(actor))
    draw_text(dx+24, dy, dw-24, line_height, actor.name)
  end

  #=============================================================================
  # Draw Actor Action
  #=============================================================================
  def draw_actor_action(actor, dx, dy)
    draw_icon(action_icon(actor), dx, dy)
  end

  #=============================================================================
  # Alias: Close
  #=============================================================================
  alias ynfbs_close close
  def close
    @SGDisplay_Window.close if @SGDisplay_Window
    ynfbs_close
  end
  
  #=============================================================================
  # Alias: Hide
  #=============================================================================
  alias ynfbs_hide hide
  def hide
    @SGDisplay_Window.hide if @SGDisplay_Window
    ynfbs_hide
  end
  
  #=============================================================================
  # Alias: Show
  #=============================================================================
  alias ynfbs_show show
  def show
    @SGDisplay_Window.show if @SGDisplay_Window
    ynfbs_show
  end
end

#===============================================================================
# Window BattleStatusAid
#===============================================================================
class Window_BattleStatusAid < Window_BattleStatus
  if $imported["YEA-BattleEngine"]
  #=============================================================================
  # Alias: Update
  #=============================================================================
    alias ynfbsa_update update
    def update
      ynfbsa_update
    end

  #=============================================================================
  #  Alias: Hide
  #=============================================================================
    alias ynfbsa_hide hide
    def hide
      @SGDisplay_Window.hide if @SGDisplay_Window
      ynfbsa_hide
    end
  
  #=============================================================================
  #  Alias: Show
  #=============================================================================
    alias ynfbsa_show show
    def show
      refresh
      @SGDisplay_Window.show
      ynfbsa_show
    end

  #=============================================================================
  #  Alias: Refresh
  #=============================================================================
	  alias ynfbs_refresh refresh
	  def refresh
		if !@SGDisplay_Window
		  @SGDisplay_Window =Window_GaugePane.new(
        self.x,self.y,self.width,self.height)
		  @SGDisplay_Window.viewport = self.viewport
		  @SGDisplay_Window.opacity = 0
		  @SGDisplay_Window.contents.font.size =
			YEA::BATTLE::BATTLESTATUS_TEXT_FONT_SIZE
		  @SGDisplay_Window.hide
		end
		@SGDisplay_Window.contents.clear
		ynfbs_refresh
	  end
	end
end
#===============================================================================
# EOF
#===============================================================================
end # End Activation Handler
