=begin ╔════════════════════════════════════════════════════════════════╗
╔──────╣            Black Wyvern Arts - RPGM-X Core - Main              ╠──────╗
╠──────╣          Black Wyvern Arts - PRGM-X Core - Debugging           ╠──────╣
╠──────╝        Black Wyvern Arts - RPGMaker-X Core - Colorspace        ╚──────╣
├──────────────────────────────────────────────────────────────────────────────┤
│ Author:  Black Wyvern                                                        │
│ Forum:   RPGMC /topic/37817-rpgm-x-core-systems-11-and-bugfix-suite/         │
│ Created: 09/01/13                                                            │
│ Updated: 04/10/16                                                            │
│ Version: 1.1.0 | 1.1.0 | 1.1.0                                               │
│ License: http://creativecommons.org/licenses/by-sa/3.0/                      │
├──────────────────────────────────────────────────────────────────────────────┤
╚──────╗               *** Only for RPG Maker VX Ace. ***               ╔──────╝
=end # ╚═──────══╦════════════════════════════════════════════╦══──────═╝
                   active = true # Turns the script on or off
=begin ══════════╩════════════════════════════════════════════╩═════════════════

  To install this script, open up your script editor and copy/paste this script
  to an open slot below ▼ Materials but above ▼ Main. Remember to save.

  Terms of use:
    1. Give credit where credit is due.
    2. You may use my code in anything you like. Commercial, non-commercial.
    3. If you edit my code in any way, please link back to the original source.
    4. Support is always appreciated in form of gold, sacrificial virgins,
        large quantaties of bacon (or other cooked meats), or free games.
          I can be contacted at LuneTheWyvern@Gmail.com

  Description:
    ► RPGMaker-X Core System (All listed functions are optional)
    - One-variable control to enable/disable all RPGM-X scripts.
    - Custom Vocab module to define text for otherwise unlabled stats
    - Enables screen resizing
      (Past a certain point you need an "Unlimited Res" script.)
    - Changes/Unifies font settings set by default and Yanfly scripts
    - Comprehensive Numeric/Boolean/Integer Logical operators and conversions
    - Quick access to party size limit
    - Windowskin options
    - Adds definitions for some RPGM-X Scripts
      (Usually, everything I make holds its own, just you know. Redundant.)

    ► RPGM-X Core Debugging
    - Integrated full Debugging Suite including on-screen console display.

    ► RPGM-X Core Colorspace
    - Converts the default 32-color palette into a 256-color palette

  Configuration:
    - None

  Instructions:
    ► RPGMaker-X Core System
    - Adds new Numeric and String class functions. See line 375+ for usage.

    ► RPGM-X Core Debugging
    - If you wish to use my stack trace information, and rapid debugging mode,
    you will need to replace your Main with the code below. I know this is
    fairly controversial, but the only way to build a diagnostics console for
    scripting exception errors is to use rescue functions for the master window.

    - Do note, that unless you have another script attaching the console to your
    game, this will disable that feature. If you want it back, you will need
    Test Edit by Hime, or something comparable that generates a console.
    (I haven't yet come across a script that outputs to, or an issue that I
    actually needed to use the console for to fix. Personal preference though.)

    It is HIGHLY recommended that you use this suite along side:
    - MOG :: Debug Mode View
    - Yanfly :: Debug Extensions

    To push mesage boxes, or the onscreen console, call them like so:
    Display(arg,[*args])
    DisplayWin(arg,[*args])
    Debug("Type","Title","Value",t/f fatal,t/f backtrace)

    If backtrace is true in Debug, it will return the full script trace that
    called it (Preferably within a rescue clause). Using the below Main will
    give a full stacktrace on Exception errors, which cover most things.

  Optional: (Place this Above)
    - RPGM-X Scripts

  Dependencies: (Place this Below)
    - None

  Compatability: (Place This Below)
    - Yanfly Engine Ace

  Credits:
    - KiloZapit :: Word Wrap
      http://www.rpgmakervxace.net/topic/6964-word-wrapping-message-boxes/
    - Yanfly :: Enemy Troop screen position fix. (Borrowed from Engine Ace)
=end # ═════════════════════════════════════════════════════════════════════════

=begin ═════════════════════════════════════════════════════════════════════════
│ RPGM-X Core Debugging Main Override
#═══════════════════════════════════════════════════════════════════════════════
# Main
# -- Launch the game, enable test mode, and handle errors should they arrise.
#═══════════════════════════════════════════════════════════════════════════════
Dumpinc() if $Dump_Includes

begin; rgss_main do
  begin
    if defined?($Rapid_Debug)
      if ($TEST && $Rapid_Debug)
        $TMT = Thread.new{system("Game.exe")}; sleep(0.01); exit
      end
    end
    $TEST = $Rapid_Debug
    attach_console if $Rapid_Debug && $Attach_Console
    SceneManager.run
  rescue RGSSReset; Graphics.transition(10); retry
  end; end
rescue SystemExit; exit
rescue Exception => error
  Debug("Exception",error.message,error.class,true,true,error.backtrace) rescue
    msgbox("Exception "+error.message+error.class.to_s+error.backtrace.inspect)
end
│ RPGM-X Core Debugging Main Override
=end # ═════════════════════════════════════════════════════════════════════════

=begin ═════════════════════════════════════════════════════════════════════════
│ Optional Scripts / Version Checking
│ - Checking to see if you have optional scripts installed and active.
│ - You probably shouldn't poke at this bit.
╞═══════════════════════════════════════════════════════════════════════════════
│ BWX::Core::Optionals.
=end # ═════════════════════════════════════════════════════════════════════════
module BWX; module Core; module Optionals
  #═════════════════════════════════════════════════════════════════════════════
  # Determine if the RPGM-X Performance Manager is installed and active.
  #═════════════════════════════════════════════════════════════════════════════
  def self.Perfman?
    return false if $imported["RPGM-X_PerfMan"].nil?
    return false unless $imported["RPGM-X_PerfMan"][0]
    return true if $imported["RPGM-X_PerfMan"][1] >= 1.0
  end
  #═════════════════════════════════════════════════════════════════════════════
  # Determine if Yanfly Battle Engine is installed.
  #═════════════════════════════════════════════════════════════════════════════
  def self.YEA_Core?
    return false if $imported["YEA-CoreEngine"].nil?
    return true
  end
end # Close BWX::Core::Optionals

#═══════════════════════════════════════════════════════════════════════════════
# ＭＯＤＵＬＥ: BWX::Core::Vars:: - Enable/Disable Core Addons
#═══════════════════════════════════════════════════════════════════════════════
module Vars
  # SLEEK GAUGE ADDON FLAGS ════════════════════════════════════════════════════
  MODULES_XC_DEBG = true  # Enable RPGM-X Core Debugging
  MODULES_XC_CSPC = true  # Enable RPGM-X Core Colorspace
end; end; end # ════════════════════════════════════════════════════════════════

#     ╔════════════════════════╗ Liek omg, actual script-like stuff starts here!
# ════╝ New Activation Handler ╚════════════════════════════════════════════════
xc_global = true
($imported||={})["BWA_RPGM-X"]=[xc_global,1.1]; if xc_global

xc_debg   = BWX::Core::Vars::MODULES_XC_DEBG
($imported||={})["RPGM-X_Debugging"]=[xc_debg,1.1]

xc_cspc   = BWX::Core::Vars::MODULES_XC_CSPC
($imported||={})["RPGM-X_Colorspace"]=[xc_cspc,1.1]
# ══════════════════════════════════════════════════════════════════════════════

=begin ═════════════════════════════════════════════════════════════════════════
│ STREWN BEFORE YOU IS A VIRTUAL CORNICOPIA OF OPTIONS AND SETTINGS FOR WHICH
│ NO ONE IN YOUR PARTY KNOWS WHAT DOES. YOU ARE TEMPTED TO PICK ONE UP AND
│ EXAMINE IT. COULD IT BE VALUABLE? COULD YOU BREW IT INTO A POTENT POLTICE?
│ PROBABLY NOT. THESE ARE SIMPLE VARIABLES AFTERALL. OH, AND IF THERE ISN'T A
│ "VIRTUAL CORNICOPIA OF OPTIONS AND SETTINGS" DISREGARD THAT MESSAGE. *WHISTLE*
=end # ═════════════════════════════════════════════════════════════════════════

$Global_Enable = true   # Master enable switch for RPGM-X scripts.

# DEBUG GLOBAL SWITCHES ════════════════════════════════════════════════════════
# - Both these options require the Main replacement given above.
# ══════════════════════════════════════════════════════════════════════════════
$Dump_Includes = false  # Dumps a list of imported scripts at boot.
$Rapid_Debug   = true   # Makes my life easier. Launches a new window in test
                        # mode. Makes it possible to code or use the DB while
                        # in game.

#═══════════════════════════════════════════════════════════════════════════════
# ＭＯＤＵＬＥ: BWX::Core::Vars::
#═══════════════════════════════════════════════════════════════════════════════
module BWX; module Core; module Vars

  # MASTER CONTROL SWITCHES ════════════════════════════════════════════════════
  MASTER_OVOCAB = true  # Override any existing vocab
  MASTER_RESIZE = true  # Resize the Game Window (Modified DLLs == Illegal!)
                        # You will need a resolution breaking script for this.
                        # Σ Res, Unlimited Res, and a few others are good.

  MASTER_OVFONT = true  # Override default Font settings
  MASTER_WINDOW = true  # Override default Window settings

  # RESOLUTION SIZE CONTROL ════════════════════════════════════════════════════
  # - Only in effect if MASTER_RESIZE == true
  # ════════════════════════════════════════════════════════════════════════════
  DSW_INT   = 1024
  DSH_INT   = 768

  # DEFAULT TEXT SETTINGS ══════════════════════════════════════════════════════
  # - Only in effect if MASTER_OVFONT == true
  # ════════════════════════════════════════════════════════════════════════════
  DFL_ARRAY = [       # Font_List
    "Myriad Pro",
    "Palatino Linotype",
    "Neuton",
    "VL Gothic",
    "Verdana"]
  DFS_INT   = 18      # Font_Size
  DFB_BOOL  = false   # Font_Bold
  DFI_BOOL  = false   # Font_Italic
  DFS_BOOL  = true    # Font_Shadowed
  DFO_BOOL  = true    # Font_Outlined
  UNIFYFNT  = true    # Automatically overrides some YEA font defaults

  # Default Font (Outline) Color
  DFC_COL   = Color.new(255,255,255,255)
  DFOC_COL  = Color.new(000,000,000,192)

  # DEFAULT WINDOW SETTINGS ════════════════════════════════════════════════════
  # - Only in effect if MASTER_WINDOW == true
  # ════════════════════════════════════════════════════════════════════════════
  WINDOW_TONE = false           # Use legacy window coloration thing
  MSGWW       = true            # Enable/Disable Word Wrap
  MAX_PARTY   = 2               # Maximum Combat Party Size
  WNDSKN      = "Windowskin"    # Window Skin Name (Blank if default)
  IS_COLS     = 3               # Number of colums to display in item/skill
                                # windows. Default is 2. May want to put it
                                # there if you aren't upscaling your rez

  # DEBUG MODULE SETTINGS ══════════════════════════════════════════════════════
  # - Only in effect if MODULES_XC_DEBG == true
  # ════════════════════════════════════════════════════════════════════════════
  DEBUG_FADETIME = 300          # Number of frames to remain onscreen
  DEBUG_MAX_LINE = 5            # Number of lines to show on the debug console
  DEBUG_SHOW_FPS = true         # Enable a small FPS gauge

  # COLORSPACE SETTINGS ════════════════════════════════════════════════════════
  # - Only in effect if MODULES_XC_CSPC == true
  # ════════════════════════════════════════════════════════════════════════════
  COLORSPACE = "Colorspace"     # Filename of the Colorspace Image
                                # (Place in Graphics/System)

  # GENERATE FONT SETTINGS ═════════════════════════════════════════════════════
  BWX_FONT  = [
    DFL_ARRAY,  DFS_INT,  DFC_COL,  DFB_BOOL,
    DFI_BOOL,   DFS_BOOL, DFO_BOOL, DFOC_COL]
end; end; end

#═══════════════════════════════════════════════════════════════════════════════
# ＭＯＤＵＬＥ: Vocab.
# - Just defines the display name, and shorthand for various variables.
# - You can change these to whatever you want.
#═══════════════════════════════════════════════════════════════════════════════
if BWX::Core::Vars::MASTER_OVOCAB
  module Vocab
    def self.xp;    "Expertise";  end   # XP
    def self.xp_a;  "Ex";         end   # XP (short)

    def self.xparam(id)
      case id
      when 0 ; "Accuracy Bonus"
      when 1 ; "Evasion Chance"
      when 2 ; "Critical Chance"
      when 3 ; "Critical Evasion"
      when 4 ; "Magic Evasion"
      when 5 ; "Magic Reflection"
      when 6 ; "Counter Attack"
      when 7 ; hp_a + " Regen / Turn"
      when 8 ; mp_a + " Regen / Turn"
      when 9 ; tp_a + " Regen / Turn"
      end
    end
    
    def self.sparam(id)
      case id
      when 0 ; "Threat Modifier"
      when 1 ; "Guard Power"
      when 2 ; "Healing Power"
      when 3 ; "Consumable Power"
      when 4 ; "Magic Fatigue"
      when 5 ; tp_a + " Restore Power"
      when 6 ; "Phys Damage Rate"
      when 7 ; "Mag Damage Rate"
      when 8 ; "Terrain Damage Rate"
      when 9 ; "Expertise Boost"
      end
    end
  end
end

=begin ═════════════════════════════════════════════════════════════════════════
│ YOU ARE FILLED WITH A SENSE OF DREAD WHEN YOU REALIZE YOU HAVE RUN OUT OF FUN
│ AND INTERESTING OPTIONS YOU CAN MESS WITH. LOOKING AROUND, ALL YOU SEE IS
│ JAGGED, UNKEPT CODE.. AND IS THAT.. BLOOD? NO, IT CAN'T BE.. BEFORE MOVING ON
│ YOU MUST MAKE AND SUCCEED A FORTITUDE CHECK. HOW'S THOSE NATURAL 20 ROLLS
│ HOLDING OUT FOR YOU NOWADAYS? OH AND SPIDERS. DID I FORGET THE SPIDERS? BIG.
=end # ═════════════════════════════════════════════════════════════════════════

#═══════════════════════════════════════════════════════════════════════════════
# ＡＢＳＴＲＡＣＴ: Graphics Resize
# - It is HIGHLY recommended to use a Plane Rewrite if you plan on using a res
#   higher than the default limit.
#═══════════════════════════════════════════════════════════════════════════════
if BWX::Core::Vars::MASTER_RESIZE
  Graphics.resize_screen(
    BWX::Core::Vars::DSW_INT,
    BWX::Core::Vars::DSH_INT)
  $ScreenRez = Rect.new(0, 0, Graphics.width, Graphics.height)

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Game_Troop.
  #═════════════════════════════════════════════════════════════════════════════
  class Game_Troop < Game_Unit
    #╒════════════════════════════════════════════════════════════════════════╤╗
    #│Yanfly::Setup (Fix battler position issues.)                            │║
    #╘════════════════════════════════════════════════════════════════════════╧╝
    def setup(troop_id)
      clear
      @troop_id = troop_id
      @enemies = []
      troop.members.each do |member|
        next unless $data_enemies[member.enemy_id]
        enemy = Game_Enemy.new(@enemies.size, member.enemy_id)
        enemy.hide if member.hidden
        enemy.screen_x = member.x + (Graphics.width - 544)/2
        enemy.screen_y = member.y + (Graphics.height - 416)
        @enemies.push(enemy)
      end
      init_screen_tone
      make_unique_names
    end
  end
end

#═══════════════════════════════════════════════════════════════════════════════
# ＡＢＳＴＲＡＣＴ: Font Definitions
#═══════════════════════════════════════════════════════════════════════════════
if BWX::Core::Vars::MASTER_OVFONT
  Font.default_name       = BWX::Core::Vars::BWX_FONT[0]
  Font.default_size       = BWX::Core::Vars::BWX_FONT[1]
  Font.default_color      = BWX::Core::Vars::BWX_FONT[2]
  Font.default_bold       = BWX::Core::Vars::BWX_FONT[3]
  Font.default_italic     = BWX::Core::Vars::BWX_FONT[4]
  Font.default_shadow     = BWX::Core::Vars::BWX_FONT[5]
  Font.default_outline    = BWX::Core::Vars::BWX_FONT[6]
  Font.default_out_color  = BWX::Core::Vars::BWX_FONT[7]
end

#═══════════════════════════════════════════════════════════════════════════════
# ＡＢＳＴＲＡＣＴ: Override Definitions
# - Nuke ALL the things! \o.
#═══════════════════════════════════════════════════════════════════════════════
if BWX::Core::Vars::UNIFYFNT
  if defined?(YEA); module YEA
    if defined?(CORE); module CORE
      FONT_NAME           = BWX::Core::Vars::BWX_FONT[0]
      FONT_SIZE           = BWX::Core::Vars::BWX_FONT[1]
      FONT_COLOUR         = BWX::Core::Vars::BWX_FONT[2]
      FONT_BOLD           = BWX::Core::Vars::BWX_FONT[3]
      FONT_ITALIC         = BWX::Core::Vars::BWX_FONT[4]
      FONT_SHADOW         = BWX::Core::Vars::BWX_FONT[5]
      FONT_OUTLINE        = BWX::Core::Vars::BWX_FONT[6]
      FONT_OUTLINE_COLOUR = BWX::Core::Vars::BWX_FONT[7]
    end; end

    if defined?(BATTLE); module BATTLE
      DEFAULT                     = BWX::Core::Vars::BWX_FONT[0]
      BATTLESTATUS_NAME_FONT_SIZE = BWX::Core::Vars::BWX_FONT[1]
      BATTLESTATUS_TEXT_FONT_SIZE = BWX::Core::Vars::BWX_FONT[1]
    end; end
    
    if defined?(ELEMENT_POPUPS); module ELEMENT_POPUPS
      DEFAULT = BWX::Core::Vars::BWX_FONT[0]
    end; end
  end; end
end

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: Numeric
# - Digit Grouping
# - Clamp value (Min/Max values)
# - Rounding, with significant figures
# - Sign logic
# - Numeric   ->  (Un)Percent
# - Numeric   ->  Boolean
# - Numeric   ->  !Boolean
# - Numeric   ->  Trinary Comparator
#═══════════════════════════════════════════════════════════════════════════════
class Numeric
  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.group
  #═════════════════════════════════════════════════════════════════════════════
  def group
    return self.to_s
    self.to_s.gsub(/(\d)(?=\d{3}(?:\.|$))(\d{3}\.)?/,'$1,$2')
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.clamp min,max
  #═════════════════════════════════════════════════════════════════════════════
  def clamp min, max
    self < min ? min : (self > max ? max : self)
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.round_to(places)
  #═════════════════════════════════════════════════════════════════════════════
  def round_to(places)
    power = 10.0**places
    (self * power).round / power
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.negative? / Numeric.positive?
  #═════════════════════════════════════════════════════════════════════════════
  def negative?; self < 0; end
  def positive?; self > 0; end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.percent / Numeric.unpercent
  #═════════════════════════════════════════════════════════════════════════════
  def percent; (self * 100).round; end
  def unpercent; self.to_f / 100; end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.to_b (Numeric to Bool) / !Numeric (Numeric to NOT Bool)
  #═════════════════════════════════════════════════════════════════════════════
  def to_b; self >= 1; end
  def !; !self.to_b; end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.to_tri(value=0) (Numeric to Trinary)
  #═════════════════════════════════════════════════════════════════════════════
  def to_tri(value=0)
    return -1 if self <  value
    return  0 if self == value
    return  1 if self >  value
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Numeric.min!(min) / Numeric.max!(max)
  #═════════════════════════════════════════════════════════════════════════════
  def min!(min);  self < min ? min : self;  end
  def max!(max);  self > max ? max : self;  end
end # Close Numeric

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: True/FlaseClass
# - Boolean  ->  Integer
#═══════════════════════════════════════════════════════════════════════════════
class TrueClass; def to_i; 1; end; end 
class FalseClass; def to_i; 0; end; end 

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: String.
# - String    ->  Boolean
# - String    ->  !Boolean
# - String    ->  Uppercase
# - String    ->  Lowercase
# - String    ->  Swapcase
# - String    ->  Perform Jumble
#═══════════════════════════════════════════════════════════════════════════════
class String
  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: String.to_b (String to Boolean) / !String (String to NOT Boolean)
  #═════════════════════════════════════════════════════════════════════════════
  #def to_b; self.downcase == "true"; end
  def to_b
    return true if self  =~ (/(on|true|t|yes|y)$/i)
    return false if self =~ (/(off|false|f|no|n)$/i)
  end
  def !; !self.to_b; end

  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: String.^ / String._ / String./ String.~
  #═════════════════════════════════════════════════════════════════════════════
  def ^; self.upcase; end
  def _; self.downcase; end
  def /; self.swapcase; end
  def ~; tr 'A-Za-z', 'N-ZA-Mn-za-m'; end
end # Close String

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: Float.
# - Float.clone
#═══════════════════════════════════════════════════════════════════════════════
class Float
  def clone; self + 0; end
end

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: Rect.
# - Fit? (TO DO)
#═══════════════════════════════════════════════════════════════════════════════
class Rect
  def fit?(rect)
  end
end

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: Game_Party.
# -- Maximum Battle Party Members
#═══════════════════════════════════════════════════════════════════════════════
class Game_Party < Game_Unit
  #═════════════════════════════════════════════════════════════════════════════
  # ＲＥＤＥＦＩＮＥ: Game_Party.max_battle_members
  #═════════════════════════════════════════════════════════════════════════════
  def max_battle_members
    return BWX::Core::Vars::MAX_PARTY
  end
end

if BWX::Core::Vars::MASTER_WINDOW
  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_Base.
  # - Color Definitions
  # - Windowskin Control
  # - KilloZapit's Wordwrap (Refer to #KZ Word Wrap)
  #═════════════════════════════════════════════════════════════════════════════
  class Window_Base < Window
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＩＮＩＴＩＡＬＩＺＥ
    #═══════════════════════════════════════════════════════════════════════════
    alias rpm_initialize initialize
    def initialize(x, y, width, height)
      rpm_initialize(x, y, width, height)
      self.windowskin = Cache.system(BWX::Core::Vars::WNDSKN)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.draw_text_dex
    #═══════════════════════════════════════════════════════════════════════════
    def draw_text_dex(x, y, text)
      text = convert_escape_characters(text)
      pos = {:x => x, :y => y, :new_x => x, :height => calc_line_height(text)}
      process_character(text.slice!(0, 1), text, pos) until text.empty?
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＡＬＩＡＳ: Window_Base.rpgmx_wb_ut < Window_Base.update_tone
    #═══════════════════════════════════════════════════════════════════════════
    alias rpgmx_wb_ut update_tone
    def update_tone(*args)
      return unless BWX::Core::Vars::WINDOW_TONE
      rpgmx_wb_ut(*args)
    end

    if BWX::Core::Vars::MSGWW
      #╒══════════════════════════════════════════════════════════════════════╤╗
      #│Kilozapit::Alias: Window_Base.process_character(c, text, pos)         │║
      #╘══════════════════════════════════════════════════════════════════════╧╝
      alias_method :process_character_kz_window_base, :process_character
      def process_character(c, text, pos)
        c = ' ' if @convert_newlines && c == "\n"
        if @wordwrap && c =~ /[ \t]/
          c = '' if @collapse_whitespace && @lastc =~ /[\s\n\f]/
          if pos[:x] + get_next_word_size(c,text)>contents.width-@right_margin
            process_new_line(text, pos)
          else
            process_normal_character(c, pos)
          end
          @lastc = c
        else
          @lastc = c
          process_character_kz_window_base(c, text, pos)
        end
      end

      #╒══════════════════════════════════════════════════════════════════════╤╗
      #│Kilozapit::Alias: Window_Base.get_next_word_size(c, text)             │║
      #╘══════════════════════════════════════════════════════════════════════╧╝
      def get_next_word_size(c, text)
        nextword = text.split(/[\s\n\f]/, 2)[0]
        if nextword
          icons = 0
          if nextword =~ /\e/i
            nextword = nextword.split(/\e[oOcC]+\[\d*\]/).join
            nextword = nextword.split(/\e[\.\|\^<>!]/).join
            nextword = nextword.split(/\e[^iIhH]+/, 2)[0]
            nextword.gsub!(/\e[iIhH]+\[[\d,]*\]/) do
              icons += 1
              ''
            end if nextword
          end
          wordsize=(nextword ?text_size(c + nextword).width: text_size(c).width)
          wordsize += icons * 24
        else
          wordsize = text_size( c ).width
        end
        return wordsize
      end

      #╒══════════════════════════════════════════════════════════════════════╤╗
      #│Kilozapit::Alias: Window_Base.process_escape_character(code,text,pos) │║
      #╘══════════════════════════════════════════════════════════════════════╧╝
      alias_method :process_escape_character_kz, :process_escape_character
      def process_escape_character(code, text, pos)
        case code.upcase
        when 'WW';  @wordwrap = true
        when 'NW';  @wordwrap = false
        when 'WS';  @convert_newlines = true
        when 'NL';  @convert_newlines = false
        when 'CS';  @collapse_whitespace = true
        when 'PRE'; @collapse_whitespace = false
        when 'BR';  process_new_line(text, pos)
          @lastc = "\n"
        when 'RM';  @right_margin = obtain_escape_param(text)
        else
          process_escape_character_kz(code, text, pos)
        end
        if pos[:x] + get_next_word_size('', text) > contents.width
          process_new_line(text, pos)
        end
      end
    end # Close Wordwrap Flag
  end # Close Window Base

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_SkillList.
  #═════════════════════════════════════════════════════════════════════════════
  class Window_SkillList < Window_Selectable
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＤＥＦＩＮＥ: Window_SkillList.col_max
    #═══════════════════════════════════════════════════════════════════════════
    def col_max
      BWX::Core::Vars::IS_COLS
    end
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_ItemList.
  #═════════════════════════════════════════════════════════════════════════════
  class Window_ItemList < Window_Selectable
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＤＥＦＩＮＥ: Window_ItemList.col_max
    #═══════════════════════════════════════════════════════════════════════════
    def col_max
      BWX::Core::Vars::IS_COLS
    end
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_ActorCommand.
  #═════════════════════════════════════════════════════════════════════════════
  class Window_ActorCommand < Window_Command
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＤＥＦＩＮＥ: add_skill_commands
    # - Sneaky insert that hides Actor Commands if they are sealed.
    #═══════════════════════════════════════════════════════════════════════════
    def add_skill_commands
      @actor.added_skill_types.sort.each do |stype_id|
        name = $data_system.skill_types[stype_id]
        next if @actor.skill_type_sealed?(stype_id)
        match = false
        for skill in @actor.skills
          next unless skill != nil
          next unless skill.stype_id == stype_id
          match = true
        end
        add_command(name, :skill, true, stype_id) if match
      end
    end
  end
end # Close Master Window Check

#═══════════════════════════════════════════════════════════════════════════════
# ＣＬＡＳＳ: Game_Actor.
#═══════════════════════════════════════════════════════════════════════════════
class Game_Actor < Game_Battler
  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Game_Actor.xp_rate
  #═════════════════════════════════════════════════════════════════════════════
  def xp_rate
    a = xp_in_level
    b = xp_to_next
    return a / b if b > 0
    return 1 unless b > 0
  end
  
  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Game_Actor.xp_to_next
  #═════════════════════════════════════════════════════════════════════════════
  def xp_to_next
    return next_level_exp - current_level_exp if level != max_level
    return 0 if level == max_level
  end
  
  #═════════════════════════════════════════════════════════════════════════════
  # ＤＥＦＩＮＥ: Game_Actor.xp_in_level
  #═════════════════════════════════════════════════════════════════════════════
  def xp_in_level
    exp - current_level_exp
  end
end

=begin ═════════════════════════════════════════════════════════════════════════
│ RPGM-X Core Debugging
│ The debugging services for RPGM are kinda.. lacking. Lets fix that shall we?
=end # ═════════════════════════════════════════════════════════════════════════

#═══════════════════════════════════════════════════════════════════════════════
# ＭＯＤＵＬＥ: BWX::Core::Debug.
#═══════════════════════════════════════════════════════════════════════════════
if BWX::Core::Vars::MODULES_XC_DEBG
  module BWX; module Core; module Debug
    #═══════════════════════════════════════════════════════════════════════════
    # Object.Debug(type,title,value,fatal=false,backtrace=false,backtracelog=[])
    #═══════════════════════════════════════════════════════════════════════════
    def Debug(type,title,value,fatal=false,backtrace=false,backtracelog=[])
      header = "BWA RPGM-X Debug Module\n"
      type = "Unknown" if type == ""

      msg = "Fatal " + type + " Error" if fatal
      msg = type unless fatal
      msg += "\n" + title.to_s if title !=""
      msg += "\nValue: " + value.to_s if value != ""
      
      if backtrace
        msg += "\nCall Backtrace:"
        i=0;  while i<=8
          exam = caller
          exam = backtracelog if !backtracelog.empty?
          unless exam[i].nil?
            info = exam[i].split(":")
            script = $RGSS_SCRIPTS[info[0][1,4].to_i][1]
            line = info[1].to_s
            code = info[2].to_s[3..-1]
            i = 15 if /<main>/.match(code)
            
            msg += "\n-- "
            msg += code if !code.nil?
            msg += " in " + script + " on line " + line
            i+=1
          else
            msg += "\nBase"; break
          end
        end
        msg += "\n"
      end
    
      msg += "\nProgram will now close." if fatal
      Display(header+msg)
      exit if fatal
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.Backtrace(count=15)
    #═══════════════════════════════════════════════════════════════════════════
    def Backtrace(count=15)
      header = "BWA RPGM-X Backtrace Module\n"
      msg = "\nCall Backtrace:"
      i = 0;  while i <= count
        exam = caller
        exam = backtracelog if !backtracelog.empty?
        unless exam[i].nil?
          info = exam[i].split(":")
          script = $RGSS_SCRIPTS[info[0][1,4].to_i][1]
          line = info[1].to_s
          code = info[2].to_s[3..-1]
          i = 15 if /<main>/.match(code)
          
          msg += "\n-- "
          msg += code if !code.nil?
          msg += " in " + script + " on line " + line
          i+=1
        else
          msg += "\nBase"; break
        end
      end
      Display(header+msg)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.VerifyArgs(hard,*args)
    #═══════════════════════════════════════════════════════════════════════════
    def VerifyArgs(hard,*args)
      verifyOK = true
      arglist = [*args]
      arglist.each do |value,type|
        case type
        when 's'
          validate = 'String'
          hard_val = 'both'
        when 'i'
          validate = 'Integer'
          hard_val = 'nil'
        when 'f'
          validate = 'Float'
          hard_val = 'nil'
        when 'b'
          validate = 'TrueClass'
          hard_val = 'nil'
        when 'b-2'
          validate = 'False'
          hard_val = 'nil'
        when 'a'
          validate = 'Array'
          hard_val = 'both'
        when 'h'
          validate = 'Hash'
          hard_val = 'both'
        end

        if hard_val == 'nil'
          verifyOK = !value.nil? && verifyOK
        else
          if hard
            verifyOK = !value.nil? && verifyOK
            verifyOK = (value.empty? rescue false) && verifyOK

            unless verifyOK
              Debug("Argument Verification","Argument is nil/empty",
                value,hard,true)
            end
          end
        end

        obj_type = Object.const_get(validate)
        verifyOK = value.is_a?(obj_type) && verifyOK
        if type == 'b' && !verifyOK
          obj_type = Object.const_get("FalseClass")
          verifyOK = value.is_a?(obj_type)
        end

        unless verifyOK
          Debug("Argument Verification","Argument is not a " + obj_type.to_s,
            value,hard,true)
        end
      end
      DisplayWin("VerifyArgs:: All Values PASS") if verifyOK
      DisplayWin("VerifyARGS:: FAIL") unless verifyOK
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.Display(*data)
    #═══════════════════════════════════════════════════════════════════════════
    def Display(*data)
      datatable = [*data]
      msg = ""
      datatable.each {|entry| msg += entry.to_s + ", "}
      msg = msg[0,msg.length-2]
      msgbox(sprintf(msg)) rescue msgbox(msg)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.DisplayWin(*data)
    #═══════════════════════════════════════════════════════════════════════════
    def DisplayWin(*data)
      if !$BWX_Debug_Window
        $BWX_Debug_Window =
          Window_BWX_Debug.new(-12,-12,Graphics.width+24,Graphics.height+24)
      end
      $BWX_Debug_Window.AddData(*data)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.Mark
    #═══════════════════════════════════════════════════════════════════════════
    def Mark
      Display("Mark")
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.DisplayFPS(fs)
    #═══════════════════════════════════════════════════════════════════════════
    def DisplayFPS(fps)
      if !$BWX_Debug_Window
        $BWX_Debug_Window =
          Window_BWX_Debug.new(-12,-12,Graphics.width+24,Graphics.height+24)
      end
      $BWX_Debug_Window.FPS(fps)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # Object.Dumpinc
    #═══════════════════════════════════════════════════════════════════════════
    def Dumpinc
      incdump = "BWA-RPM Debug Module\nList of $imported scripts.\n\n"
      $imported.keys.each do |i|
        incdump+=i.to_s + " | "
      end
      msgbox(sprintf(incdump))
    end
  end; end; end # Close BWX::Core::Debug.
  include BWX::Core::Debug

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Scene_Base.
  #═════════════════════════════════════════════════════════════════════════════
  class Scene_Base
    #═══════════════════════════════════════════════════════════════════════════
    # ＡＬＩＡＳ: Scene_Base.bwx_debug_update < Scene_Base.update
    #═══════════════════════════════════════════════════════════════════════════
    alias bwx_debug_update update
    def update
      bwx_debug_update
      $BWX_Debug_Window.update if $BWX_Debug_Window
    end
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_BWX_Debug.
  # - Dialog boxes are cool. On-screen console diagnostics are cooler.
  # - Highly recommended to be used with Yanfly In-Game Debugging
  #═════════════════════════════════════════════════════════════════════════════
  class Window_BWX_Debug < Window_Base
    #═══════════════════════════════════════════════════════════════════════════
    # ＩＮＩＴＩＡＬＩＺＥ
    #═══════════════════════════════════════════════════════════════════════════
    def initialize(x,y,h,w)
      super
      self.opacity = 0
      # -- Console Vars
      @datalog = []
      @drawtime = 0
      @dbcnframe = 0
      @fadetime = BWX::Core::Vars::DEBUG_FADETIME
      @maxitems = BWX::Core::Vars::DEBUG_MAX_LINE
      self.z = 5000
    end
    
    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_BWX_Debug.AddData(*data)
    #═══════════════════════════════════════════════════════════════════════════
    def AddData(*data)
      datatable = [*data]
      info = caller[2].split(":")
      script = $RGSS_SCRIPTS[info[0][1,4].to_i][1]
      line = info[1].to_s
      code = info[2].to_s[3..-1]
      datatable.each {|item|
        @datalog.unshift [item,@drawtime,script,line,code]
      @drawtime = 1 if @drawtime <= 0}
    end

    def FPS(fps)
      offset = ((@maxitems+1)*16)
      contents.clear_rect(9,offset,200,15)
      fps_rate = fps/60.0
      draw_gauge(10,offset+10,150,fps_rate,
        Color.new(150,0,0),Color.new(0,128,255))
      draw_text_dex(10,offset-3,fps.to_s+" FPS ("+Graphics.frame_count.to_s+")")
    end
    
    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_BWX_Debug.draw_text_dex(x, y, text)
    #═══════════════════════════════════════════════════════════════════════════
    def draw_text_dex(x, y, text)
      text = convert_escape_characters(text)
      pos = {:x => x, :y => y, :new_x => x, :height => calc_line_height(text)}
      process_character(text.slice!(0, 1), text, pos) until text.empty?
    end
    
    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_BWX_Debug.update
    #═══════════════════════════════════════════════════════════════════════════
    def update
      super
      # -- Console Update
      if @drawtime > 0
        @drawtime += 1

        if BWX::Core::Optionals.Perfman?
          return if $FSX.Skip?(10)
        else
          @dbcnframe += 1
          return unless @dbcnframe % 10 == 0
          @dbcnframe = 0 if @dbcnframe > 100
        end

        @drawn_at = @datalog[0][1].to_f
        while @datalog.length > @maxitems*2; @datalog.pop; end
        while !@datalog.empty? && @drawtime - @datalog[-1][1] > @fadetime
          @datalog.pop
        end
        if @datalog.empty?
          @drawtime = 0
          return
        end

        bgsize = contents.rect
        bgsize.height = @maxitems * 16 + 8
        
        rate = (1-(@drawtime - @drawn_at) / @fadetime.to_f).round(2).clamp 0,1
        contents.gradient_fill_rect(bgsize,
          Color.new(0,0,0,192*rate),Color.new(0,0,0,50*rate),true)

        i = 0
        for item in @datalog
          xpos = i < @maxitems ? 0 : contents.width/2
          draw_text_dex(xpos,((i % @maxitems)*16),
            #"[" + item[2].to_s + " {" + item[3].to_s + "}] " +
            # This gives a bit more information, but may exceed your screen area.
            item[4].to_s + " " + item[0].to_s)
          i+=1
        end
      elsif @drawtime == 0
        contents.clear
        @drawtime -= 1
      end
    end # Close Update
  end # Close Window BWX Debug

  #═════════════════════════════════════════════════════════════════════════════
  # ＭＯＤＵＬＥ: Graphics.
  # - Inject FPS Counter
  #═════════════════════════════════════════════════════════════════════════════
  module Graphics
    if BWX::Core::Vars::DEBUG_SHOW_FPS
      @fps, @fps_tmp = 0, []
      attr_reader :fps
      class << self
        alias fps_update update unless method_defined?(:fps_update)
        def update
          t = Time.now
          fps_update
          @fps_tmp[frame_count % frame_rate] = Time.now != t
          @fps = 0
          frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
          DisplayFPS(@fps)
        end
      end
    end
  end

  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Game_Interpreter.
  # - Event Script Error Handling
  #═════════════════════════════════════════════════════════════════════════════
  class Game_Interpreter
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＤＥＦＩＮＥ: Game_Interpreter.command_355
    #═══════════════════════════════════════════════════════════════════════════
    def command_355
      script = @list[@index].parameters[0] + "\n"
      while next_event_code == 655
        @index += 1
        script += @list[@index].parameters[0] + "\n"
      end
      eval(script) rescue
        Debug("Event Script","Unknown method called in map event.",
          script,true,false)
    end
  end
end # Close RPGM-X Debug

=begin ═════════════════════════════════════════════════════════════════════════
│ RPGM-X Core Colorspace
│ That moment when you realize 32 colors just aren't enough.
=end # ═════════════════════════════════════════════════════════════════════════

if BWX::Core::Vars::MODULES_XC_CSPC
  #═════════════════════════════════════════════════════════════════════════════
  # ＣＬＡＳＳ: Window_Base.
  # - Extends the basic 32-space windowskin palette to a 256-space.
  #═════════════════════════════════════════════════════════════════════════════
  class Window_Base < Window
    attr_reader :colorspace
    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＩＮＩＴＩＡＬＩＺＥ
    #═══════════════════════════════════════════════════════════════════════════
    alias xccs_init initialize
    def initialize(*args)
      xccs_init(*args)
      @colorspace = Cache.system(BWX::Core::Vars::COLORSPACE)
      @xccs_colors = {
      :normal     =>  0,    :param_atk1 => 16,    :hp_full_l  => 32,
      :system     =>  1,    :param_atk2 => 17,    :hp_full_r  => 33,
      :crisis     =>  2,    :param_def1 => 18,    :hp_empt_l  => 34,
      :knockout   =>  3,    :param_def2 => 19,    :hp_empt_r  => 35,
      :mp_cost    =>  4,    :param_mat1 => 20,    :mp_full_l  => 36,
      :tp_cost    =>  5,    :param_mat2 => 21,    :mp_full_r  => 37,
      :wp_cost    =>  6,    :param_mdf1 => 22,    :mp_empt_l  => 38,
      :vc_cost    =>  7,    :param_mfd2 => 23,    :mp_empt_r  => 39,
      :lf_cost    =>  8,    :param_agi1 => 24,    :tp_full_l  => 40,
      :dv_cost    =>  9,    :param_agi2 => 25,    :tp_full_r  => 41,
      :power_up   => 10,    :param_luk1 => 26,    :tp_empt_l  => 42,
      :power_down => 11,    :param_luk2 => 27,    :tp_empt_r  => 43,
      :gauge_back => 12,    :param_dex1 => 28,    :wp_full_l  => 44,
      :sg_bordr1  => 13,    :param_dex2 => 29,    :wp_full_r  => 45,
      :sg_bordr2  => 14,    :param_foc1 => 30,    :wp_empt_l  => 46,
      :sg_gback2  => 15,    :param_foc2 => 31,    :wp_empt_r  => 47,

      :vc_full_l  => 48,    :sub_full_l => 64,
      :vc_full_r  => 49,    :sub_full_r => 65,
      :vc_empt_l  => 50,    :sub_empt_l => 66,
      :vc_empt_r  => 51,    :sub_empt_l => 67,
      :lf_full_l  => 52,    :exp_full_l => 68,
      :lf_full_r  => 53,    :exp_full_r => 69,
      :lf_empt_l  => 54,    :exp_empt_l => 70,
      :lf_empt_r  => 55,    :exp_empt_r => 71,
      :dv_full_l  => 56,    :mhpb_mhf_l => 72,
      :dv_full_r  => 57,    :mhpb_mhf_r => 73,
      :dv_empt_l  => 58,    :mhpb_mhe_l => 74,
      :dv_empt_r  => 59,    :mhpb_mhe_r => 75,
      :sp_full_l  => 60,    :mhpb_bhf_l => 76,
      :sp_full_r  => 61,    :mhpb_bhf_r => 77,
      :sp_empt_l  => 62,    :mhpb_bhe_l => 78,
      :sp_empt_r  => 63,    :mhpb_bhe_r => 79,
    }
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＲＥＤＥＦＩＮＥ: Window_Base.text_color(n)
    #═══════════════════════════════════════════════════════════════════════════
    def text_color(n)
      Index_Color(n)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.Get_Color(n)
    #═══════════════════════════════════════════════════════════════════════════
    def Get_Color(n)
      Index_Color(n)
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.Index_Color(n)
    #═══════════════════════════════════════════════════════════════════════════
    def Index_Color(n)
      row = (n / 16).to_i; col = (n % 16); off = [0,0]
      case row
        when 0 || 4 ||  8 || 12;  col.even? ? off = [0,0] : off = [3,0]
        when 1 || 5 ||  9 || 13;  col.even? ? off = [3,3] : off = [0,3]
        when 2 || 6 || 10 || 14;  col.even? ? off = [3,0] : off = [0,0]
        when 3 || 7 || 11 || 15;  col.even? ? off = [0,3] : off = [3,3]
      end
      return @colorspace.get_pixel(
        (col*4)+off[0],(((row/2).floor)*4)+off[1])
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.@xccs_colors
    #═══════════════════════════════════════════════════════════════════════════
    def xccs_colors(sym)
      @xccs_colors[sym]
    end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.(color definitions)
    #═══════════════════════════════════════════════════════════════════════════
    def normal_color;     Index_Color(@xccs_colors[:normal]);     end
    def system_color;     Index_Color(@xccs_colors[:system]);     end
    def crisis_color;     Index_Color(@xccs_colors[:crisis]);     end
    def knockout_color;   Index_Color(@xccs_colors[:knockout]);   end
    def hp_cost_color;    Index_Color(@xccs_colors[:hp_full_r]);  end
    def mp_cost_color;    Index_Color(@xccs_colors[:mp_cost]);    end
    def tp_cost_color;    Index_Color(@xccs_colors[:tp_cost]);    end
    def wp_cost_color;    Index_Color(@xccs_colors[:wp_cost]);    end
    def vc_cost_color;    Index_Color(@xccs_colors[:vc_cost]);    end
    def lf_cost_color;    Index_Color(@xccs_colors[:lf_cost]);    end
    def dv_cost_color;    Index_Color(@xccs_colors[:dv_cost]);    end
    def power_up_color;   Index_Color(@xccs_colors[:power_up]);   end
    def power_down_color; Index_Color(@xccs_colors[:power_down]); end
    def gauge_back_color; Index_Color(@xccs_colors[:gauge_back]); end
    def gauge_border_1;   Index_Color(@xccs_colors[:sg_bordr1]);  end
    def gauge_border_2;   Index_Color(@xccs_colors[:sg_gback2]);  end
    def gauge_back_sgalt; Index_Color(@xccs_colors[:sg_gback2]);  end
    
    def param_atk_col1;   Index_Color(@xccs_colors[:param_atk1]); end
    def param_atk_col2;   Index_Color(@xccs_colors[:param_atk2]); end
    def param_def_col1;   Index_Color(@xccs_colors[:param_def1]); end
    def param_def_col2;   Index_Color(@xccs_colors[:param_def2]); end
    def param_mat_col1;   Index_Color(@xccs_colors[:param_mat1]); end
    def param_mat_col2;   Index_Color(@xccs_colors[:param_mat2]); end
    def param_mdf_col1;   Index_Color(@xccs_colors[:param_mdf1]); end
    def param_mdf_col2;   Index_Color(@xccs_colors[:param_mdf2]); end
    def param_agi_col1;   Index_Color(@xccs_colors[:param_agi1]); end
    def param_agi_col2;   Index_Color(@xccs_colors[:param_agi2]); end
    def param_luk_col1;   Index_Color(@xccs_colors[:param_luk1]); end
    def param_luk_col2;   Index_Color(@xccs_colors[:param_luk2]); end
    def param_dex_col1;   Index_Color(@xccs_colors[:param_dex1]); end
    def param_dex_col2;   Index_Color(@xccs_colors[:param_dex2]); end
    def param_foc_col1;   Index_Color(@xccs_colors[:param_foc1]); end
    def param_foc_col2;   Index_Color(@xccs_colors[:param_foc2]); end
    
    def hp_gauge_color1;  Index_Color(@xccs_colors[:hp_full_l]);  end
    def hp_gauge_color2;  Index_Color(@xccs_colors[:hp_full_r]);  end
    def hp_gauge_color3;  Index_Color(@xccs_colors[:hp_empt_l]);  end
    def hp_gauge_color4;  Index_Color(@xccs_colors[:hp_empt_r]);  end
    def mp_gauge_color1;  Index_Color(@xccs_colors[:mp_full_l]);  end
    def mp_gauge_color2;  Index_Color(@xccs_colors[:mp_full_r]);  end
    def mp_gauge_color3;  Index_Color(@xccs_colors[:mp_empt_l]);  end
    def mp_gauge_color4;  Index_Color(@xccs_colors[:mp_empt_r]);  end
    def tp_gauge_color1;  Index_Color(@xccs_colors[:tp_full_l]);  end
    def tp_gauge_color2;  Index_Color(@xccs_colors[:tp_full_r]);  end
    def tp_gauge_color3;  Index_Color(@xccs_colors[:tp_empt_l]);  end
    def tp_gauge_color4;  Index_Color(@xccs_colors[:tp_empt_r]);  end
    def wp_gauge_color1;  Index_Color(@xccs_colors[:wp_gauge1]);  end
    def wp_gauge_color2;  Index_Color(@xccs_colors[:wp_gauge2]);  end
    def wp_gauge_color3;  Index_Color(@xccs_colors[:wp_empt_l]);  end
    def wp_gauge_color4;  Index_Color(@xccs_colors[:wp_empt_r]);  end
    
    def vc_gauge_color1;  Index_Color(@xccs_colors[:vc_full_l]);  end
    def vc_gauge_color2;  Index_Color(@xccs_colors[:vc_full_r]);  end
    def vc_gauge_color3;  Index_Color(@xccs_colors[:vc_empt_l]);  end
    def vc_gauge_color4;  Index_Color(@xccs_colors[:vc_empt_r]);  end
    def lf_gauge_color1;  Index_Color(@xccs_colors[:lf_full_l]);  end
    def lf_gauge_color2;  Index_Color(@xccs_colors[:lf_full_r]);  end
    def lf_gauge_color3;  Index_Color(@xccs_colors[:lf_empt_l]);  end
    def lf_gauge_color4;  Index_Color(@xccs_colors[:lf_empt_r]);  end
    def dv_gauge_color1;  Index_Color(@xccs_colors[:dv_full_l]);  end
    def dv_gauge_color2;  Index_Color(@xccs_colors[:dv_full_2]);  end
    def dv_gauge_color3;  Index_Color(@xccs_colors[:dv_empt_l]);  end
    def dv_gauge_color4;  Index_Color(@xccs_colors[:dv_empt_r]);  end
    def sp_gauge_color1;  Index_Color(@xccs_colors[:sp_full_1]);  end
    def sp_gauge_color2;  Index_Color(@xccs_colors[:sp_full_2]);  end
    def sp_gauge_color3;  Index_Color(@xccs_colors[:sp_empt_l]);  end
    def sp_gauge_color4;  Index_Color(@xccs_colors[:sp_empt_r]);  end
    
    def subparam_color1;  Index_Color(@xccs_colors[:sub_full_l]); end
    def subparam_color2;  Index_Color(@xccs_colors[:sub_full_r]); end
    def subparam_color3;  Index_Color(@xccs_colors[:sub_empt_r]); end
    def subparam_color4;  Index_Color(@xccs_colors[:sub_empt_l]); end
    def xp_gauge_color1;  Index_Color(@xccs_colors[:exp_full_l]); end
    def xp_gauge_color2;  Index_Color(@xccs_colors[:exp_full_r]); end
    def xp_gauge_color3;  Index_Color(@xccs_colors[:exp_empt_l]); end
    def xp_gauge_color4;  Index_Color(@xccs_colors[:exp_empt_r]); end

    #═══════════════════════════════════════════════════════════════════════════
    # ＤＥＦＩＮＥ: Window_Base.Auto_Color(*args)
    #═══════════════════════════════════════════════════════════════════════════
    def Auto_Color(*args)
      acargs = [*args]
      case acargs.length
      when 2
        colors = acargs[0]
        col1 = Index_Color(colors[0])
        col2 = Index_Color(colors[1])
        rate = acargs[1]
      when 3
        col1 = acargs[0]
        col2 = acargs[1]
        rate = acargs[2]
      else; fail = true
      end

      if fail
        Debug("Auto_Color Error","Wrong number of arguments",
          acargs.length.to_s + " for (2..3)",false, true) rescue
        msgbox("Auto_Color Error \n Wrong number of arguments\n",
          acargs.length.to_s + " for (2..3)",)
        return Color.new(0,0,0)
      end

      a_col = Color.new
      a_col.red    = (1 - rate) * col2.red +    rate * col1.red
      a_col.green  = (1 - rate) * col2.green +  rate * col1.green
      a_col.blue   = (1 - rate) * col2.blue +   rate * col1.blue
      a_col.alpha  = (1 - rate) * col2.alpha +  rate * col1.alpha
      return a_col
    end # Close Auto_Color
  end # Close Window Base
end # Close Core Colorspace
# ══════════════════════════════════════════════════════════════════════════════
# ════╗ End Activation Handler ╔════════════════════════════════════════════════
end # ╚════════════════════════╝ End of File - Srsly, there's nothing more here!
