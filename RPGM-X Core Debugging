=begin
#===============================================================================
  Black Wyvern Arts - RPGMaker-X Debugging Tools
  Author: Black Wyvern
  Created: 09/21/16
  Updated: 03/21/16
  Version: 1.0
#===============================================================================
  *** Only for RPG Maker VX Ace. ***
  ------------------------------------------------------------------------------
  To install this script, open up your script editor and copy/paste this script
  to an open slot below ▼ Materials but above ▼ Main. Remember to save.
  
  Terms of use:
    1. Give credit where credit is due.
    2. You may use my code in anything you like. Commercial, non-commercial.
    3. If you edit my code in any way, please link back to the original source.
    4. Support is always appreciated in form of gold, sacrificial virgins,
        large quantaties of bacon (or other cooked meats), or free games.
          I can be contacted at LuneTheWyvern@Gmail.com

  Description:
    - Integrated full Debugging Suite including on-screen console display.
  
  Configuration:
    - None
  
  Instructions: Plug 'n' Play
    This needs to be located below the RPGM-X Core System.
    Order:
      Core System
      Debugging
      Colorspace
      -Others-

    ►►► DEBUGGING TOOLS INFORMATION ◄◄◄
    If you wish to use my stack trace information, and rapid debugging mode,
    you will need to replace your Main with the following code. I know this is
    fairly controversial, but the only way to build a diagnostics console for
    scripting exception errors is to use rescue functions for the master window.

#===============================================================================
# Main
# -- Launch the game, enable test mode, and handle errors should they arrise.
#===============================================================================
Dumpinc() if $Dump_Includes

begin; rgss_main do
  begin
    if defined?($Rapid_Debug); if ($TEST && $Rapid_Debug)
      Thread.new{system("Game.exe")}; sleep(0.01); exit
    end; end
    SceneManager.run
  rescue RGSSReset; Graphics.transition(10); retry
  end; end
rescue SystemExit; exit
rescue Exception => error
  Debug("Exception",error.message,error.class,true,true,error.backtrace)
end

    Do note, that unless you have another script attaching the console to your
    game, this will disable that feature. If you want it back, you will need
    Test Edit by Hime, or something comparable that generates a console.
    (I haven't yet come across a script that outputs to, or an issue that I
    actually needed to use the console for to fix. Personal preference though.)

    It is HIGHLY recommended that you use this suite along side:
    -- MOG :: Debug Mode View
    -- Yanfly :: Debug Extensions

    To push mesage boxes, or the onscreen console, call them like so:
    Display(arg,[*args])
    DisplayWin(arg,[*args])
    Debug("Type","Title","Value",t/f fatal,t/f backtrace)

    If backtrace is true in Debug, it will return the full script trace that
    called it (Preferably within a rescue clause). Using the below Main will
    give a full stacktrace on Exception errors, which cover most things.
  
  ►►► END OF DEBUGGING TOOLS INFORMATION ◄◄◄

  Optional:
    - None
  
  Dependencies:
    - None
  
  Compatability:
    - None

  Credits:
    - None
#===============================================================================
=end

active = true # Turns the script on or off.
if (!$Global_Enable.nil? && active) || ($Global_Enable && active)
  ($imported||={})["RPGM-X_Debugging"]=[true,1.0]
  # ^ Signifies that the script is installed to other scripts.

#===============================================================================
# Debug Module
# -- I use this module to monitor output from my scripts if they asplode.
#===============================================================================

# Both these options require the Main replacement given above.
$Dump_Includes = false  # Dumps a list of imported scripts at boot.
$Rapid_Debug = true     # Makes my life easier. Launches a new window in test
                        # mode. Makes it possible to code or use the DB while
                        # in game.
module BWX
  module Debug
    MAX_CONSOLE_LINE = 5  # Number of lines to display on the on-screen console

#===============================================================================
#   ►►► WARNING: YOU PROBABLY SHOULDN'T EDIT ANYTHING BELOW THIS POINT ◄◄◄
#   ►►►  CUZ YEAH, THERE'S NOTHING REALLY CONFIGURABLE, AND IT DOESN'T ◄◄◄
#   ►►►              LIKE IT WHEN YOU TOUCH IT THAT WAY.               ◄◄◄
#===============================================================================

    #===========================================================================
    # Debug Dialog
    #===========================================================================
    def Debug(type, title, value, fatal=false, backtrace=false, backtracelog=[])
      header = "BWA RPGM-X Debug Module\n"
      if type == ""; type = "Unknown"
      elsif type._ == "version"
        type = "Core Version Error"
      end

      msg = "Fatal " + type + " Error" if fatal
      msg = type unless fatal
      
      msg += "\n" + title.to_s if title !=""
      
      msg += "\nValue: " + value.to_s if value != ""
      
      if backtrace
        msg += "\nCall Backtrace:"
        i=0;  while i<=8
          exam = caller
          exam = backtracelog if !backtracelog.empty?
          unless exam[i].nil?
            info = exam[i].split(":")
            script = $RGSS_SCRIPTS[info[0][1,4].to_i][1]
            line = info[1].to_s
            code = info[2].to_s[3..-1]
            i = 9 if /<main>/.match(code)
            
            msg += "\n-- "
            msg += code if !code.nil?
            msg += " in " + script + " on line " + line
            i+=1
          else
            msg += "\nBase"; break
          end
        end
        msg += "\n"
      end
      
      msg += "\nProgram will now close." if fatal
      Display(header+msg) if fatal || backtrace
      DisplayWin(sprintf(header+msg)) if !fatal && !backtrace
      exit if fatal
    end
    
    #===========================================================================
    # Display Dialog
    #===========================================================================
    def Display(*data)
      datatable = [*data]
      msg = ""
      datatable.each {|entry| msg += entry.to_s + ", "}
      msg = msg[0,msg.length-2]
      msgbox(sprintf(msg)) rescue msgbox(msg)
    end
    
    #===========================================================================
    # Display Window
    #===========================================================================
    def DisplayWin(*data)
      if !$BWX_Debug_Window
        $BWX_Debug_Window =
          Window_BWX_Debug.new(-12,-12,Graphics.width+24,Graphics.height+24)
      end
      $BWX_Debug_Window.AddData(*data)
    end
    
    #===========================================================================
    # Dump Included Files
    #===========================================================================
    def Dumpinc
      incdump = "BWA-RPM Debug Module\nList of $imported scripts.\n\n"
      $imported.keys.each do |i|
        incdump+=i.to_s + " | "
      end
      msgbox(sprintf(incdump))
    end
  end
end
include BWX::Debug

#===============================================================================
# Scene Base
# -- Add DebugWin to the Scene Manager.
#===============================================================================
class Scene_Base
  #=============================================================================
  # Alias: Update
  #=============================================================================
  alias bwx_debug_update update
  def update
    bwx_debug_update
    $BWX_Debug_Window.update if $BWX_Debug_Window
  end
end

#===============================================================================
# Window BWX Debug
# -- Dialog boxes are cool. On-screen console diagnostics are cooler.
# -- Highly recommended to be used with Yanfly In-Game Debugging
#===============================================================================
class Window_BWX_Debug < Window_Base
  #=============================================================================
  # Initialize
  #=============================================================================
  def initialize(x,y,h,w)
    super
    self.opacity = 0
    @datalog = []
    @drawtime = 0
    @fadetime = 300
    @frame = 0
    @maxitems = BWX::Debug::MAX_CONSOLE_LINE
    self.z = 5000
  end
  
  #=============================================================================
  # Add Data
  #=============================================================================
  def AddData(*data)
    datatable = [*data]
    info = caller[2].split(":")
    script = $RGSS_SCRIPTS[info[0][1,4].to_i][1]
    line = info[1].to_s
    code = info[2].to_s[3..-1]
    datatable.each {|item|
      @datalog.unshift [item,@drawtime,script,line,code]
    @drawtime = 1 if @drawtime <= 0}
  end
  
  def draw_text_dex(x, y, text)
    text = convert_escape_characters(text)
    pos = {:x => x, :y => y, :new_x => x, :height => calc_line_height(text)}
    process_character(text.slice!(0, 1), text, pos) until text.empty?
  end
  
  #=============================================================================
  # Update
  #=============================================================================
  def update
    super
    if @drawtime > 0
      @drawtime += 1

      @frame += 1
      return unless @frame % 10 == 0
      @frame = 0 if @frame > 100

      @drawn_at = @datalog[0][1].to_f
      while @datalog.length > @maxitems*2; @datalog.pop; end
      while !@datalog.empty? && @drawtime - @datalog[-1][1] > @fadetime
        @datalog.pop
      end
      if @datalog.empty?
        @drawtime = 0
        return
      end

      bgsize = contents.rect
      bgsize.height = @maxitems * 16 + 8
      
      rate = (1-(@drawtime - @drawn_at) / @fadetime.to_f).round(2).clamp 0,1
      contents.gradient_fill_rect(bgsize,
        Color.new(0,0,0,192*rate),Color.new(0,0,0,50*rate),true)

      i = 0
      for item in @datalog
        xpos = i < @maxitems ? 0 : contents.width/2
        draw_text_dex(xpos,((i % @maxitems)*16),
          "[" + item[2].to_s + " {" + item[3].to_s + "}] " +
          item[4].to_s + " " + item[0].to_s)
        i+=1
      end

    elsif @drawtime == 0
      contents.clear
      @drawtime -= 1
    end
  end
end

#===============================================================================
# Game Interpreter Event Script Error
#===============================================================================
class Game_Interpreter
  def command_355
    script = @list[@index].parameters[0] + "\n"
    while next_event_code == 655
      @index += 1
      script += @list[@index].parameters[0] + "\n"
    end
    eval(script) rescue
      Debug("Event Script","Unknown method called in map event.",
        script,true,false)
  end
end
#===============================================================================
# EOF
#===============================================================================
end # End Activation Handler
